---
sidebar_position: 99
title: "DiamondMod"
description: "Manages diamond facets and fallback logic"
gitSource: "https://github.com/maxnorm/Compose/blob/00106e341b257629f718c654a349c0ad60a7cf8a/src/diamond/DiamondMod.sol"
---

import DocSubtitle  from '@site/src/components/docs/DocSubtitle';
import Badge from '@site/src/components/ui/Badge';
import Callout from '@site/src/components/ui/Callout';
import CalloutBox from '@site/src/components/ui/CalloutBox';
import Accordion, { AccordionGroup } from '@site/src/components/ui/Accordion';
import PropertyTable from '@site/src/components/api/PropertyTable';
import ExpandableCode from '@site/src/components/code/ExpandableCode';
import CodeShowcase from '@site/src/components/code/CodeShowcase';
import RelatedDocs from '@site/src/components/docs/RelatedDocs';
import WasThisHelpful from '@site/src/components/docs/WasThisHelpful';
import LastUpdated from '@site/src/components/docs/LastUpdated';
import ReadingTime from '@site/src/components/docs/ReadingTime';
import GradientText from '@site/src/components/ui/GradientText';
import GradientButton from '@site/src/components/ui/GradientButton';

<DocSubtitle>
Manages diamond facets and fallback logic
</DocSubtitle>

<Callout type="info" title="Key Features">
- Manages facet registration and function selector mapping.
- Implements the diamond fallback mechanism for routing calls to appropriate facets.
- Supports adding multiple facets and their functions in a single operation during deployment.
</Callout>

<Callout type="info" title="Module Usage">
This module provides internal functions for use in your custom facets. Import it to access shared logic and storage.
</Callout>

## Overview

The DiamondMod provides core logic for managing facets within a Compose diamond. It handles adding facets during deployment and routing external calls to the correct facet, ensuring composability and proper execution of diamond functions. This module is fundamental for extending diamond functionality.

---

## Storage

### FacetCutAction

Add=0, Replace=1, Remove=2

---
### DiamondStorage

storage-location: erc8042:compose.diamond

<ExpandableCode language="solidity" maxLines={15} title="Definition">
{`struct DiamondStorage {
mapping(bytes4 functionSelector => FacetAndPosition) facetAndPosition;
/**
 * \`selectors\` contains all function selectors that can be called in the diamond.
 */
bytes4[] selectors;
}`}
</ExpandableCode>

---
### FacetAndPosition

<ExpandableCode language="solidity" maxLines={15} title="Definition">
{`struct FacetAndPosition {
address facet;
uint32 position;
}`}
</ExpandableCode>

---
### FacetCut

<ExpandableCode language="solidity" maxLines={15} title="Definition">
{`struct FacetCut {
address facetAddress;
FacetCutAction action;
bytes4[] functionSelectors;
}`}
</ExpandableCode>

### State Variables

<PropertyTable
  properties={[
    {
      name: "DIAMOND_STORAGE_POSITION",
      type: "bytes32",
      description: "Diamond storage slot position for this module (Value: `keccak256(\"compose.diamond\")`)"
    }
  ]}
  showRequired={false}
/>

## Functions

### addFacets

Adds facets and their function selectors to the diamond. Only supports adding functions during diamond deployment.

<ExpandableCode language="solidity" maxLines={8}>
{`function addFacets(FacetCut[] memory _facets) ;`}
</ExpandableCode>

**Parameters:**

<PropertyTable
  properties={[
    {
      name: "_facets",
      type: "FacetCut[]",
      description: ""
    }
  ]}
  showRequired={false}
/>

---
### diamondFallback

Find facet for function that is called and execute the function if a facet is found and return any value.

<ExpandableCode language="solidity" maxLines={8}>
{`function diamondFallback() ;`}
</ExpandableCode>

---
### getStorage

<ExpandableCode language="solidity" maxLines={8}>
{`function getStorage() pure returns (DiamondStorage storage s);`}
</ExpandableCode>

## Events

<AccordionGroup>
  <Accordion title="DiamondCut" defaultOpen={false}>

    <div style={{marginBottom: "1rem"}}>
      <strong>Signature:</strong>
      <ExpandableCode language="solidity" maxLines={5}>
{`event DiamondCut(FacetCut[] _diamondCut, address _init, bytes _calldata);`}
      </ExpandableCode>
    </div>

  </Accordion>
</AccordionGroup>

## Errors

<AccordionGroup>
  <Accordion title="CannotAddFunctionToDiamondThatAlreadyExists" defaultOpen={false}>

    <div>
      <strong>Signature:</strong>
      <ExpandableCode language="solidity" maxLines={5}>
error CannotAddFunctionToDiamondThatAlreadyExists(bytes4 _selector);
      </ExpandableCode>
    </div>
  </Accordion>
  <Accordion title="FunctionNotFound" defaultOpen={false}>

    <div>
      <strong>Signature:</strong>
      <ExpandableCode language="solidity" maxLines={5}>
error FunctionNotFound(bytes4 _selector);
      </ExpandableCode>
    </div>
  </Accordion>
  <Accordion title="InvalidActionWhenDeployingDiamond" defaultOpen={false}>

    <div>
      <strong>Signature:</strong>
      <ExpandableCode language="solidity" maxLines={5}>
error InvalidActionWhenDeployingDiamond(address facetAddress, FacetCutAction action, bytes4[] functionSelectors);
      </ExpandableCode>
    </div>
  </Accordion>
  <Accordion title="NoBytecodeAtAddress" defaultOpen={false}>

    <div>
      <strong>Signature:</strong>
      <ExpandableCode language="solidity" maxLines={5}>
error NoBytecodeAtAddress(address _contractAddress, string _message);
      </ExpandableCode>
    </div>
  </Accordion>
</AccordionGroup>

## Usage Example

<ExpandableCode language="solidity" maxLines={20} title="Example Implementation">
{`pragma solidity ^0.8.30;

import {IDiamondMod} from "@compose/contracts/diamond/interfaces/IDiamondMod.sol";

contract MyFacet {
    IDiamondMod internal diamondMod;

    constructor(address _diamondMod) {
        diamondMod = IDiamondMod(_diamondMod);
    }

    /**
     * @notice Example of calling a function through the diamond proxy.
     */
    function callFacetFunction(bytes4 _selector, address _facetAddress) external returns (bytes memory) {
        // In a real scenario, you would likely not pass the facet address directly
        // but rather let diamondFallback resolve it. This is for demonstration.
        return diamondMod.diamondFallback(_selector, _facetAddress, "");
    }
}`}
</ExpandableCode>

## Best Practices

<Callout type="tip" title="Best Practice">
- Facet additions are restricted to the initial diamond deployment phase.
- Ensure correct function selector mapping when adding facets to prevent routing issues.
- Handle potential errors such as `FunctionNotFound` or `CannotAddFunctionToDiamondThatAlreadyExists`.
</Callout>

## Integration Notes

<Callout type="success" title="Shared Storage">
DiamondMod interacts directly with the diamond proxy's storage to maintain mappings of function selectors to facet addresses. The `addFacets` function is designed to be called only during the initial deployment of the diamond. The `diamondFallback` function is crucial for the diamond proxy's operation, as it resolves incoming function calls to their respective facets. Any changes to facet mappings managed by this module are immediately reflected in the diamond's behavior.
</Callout>

<div style={{marginTop: "3rem", paddingTop: "2rem", borderTop: "1px solid var(--ifm-color-emphasis-200)"}}>
  <WasThisHelpful pageId="DiamondMod" />
</div>

<LastUpdated date="2025-12-20T03:05:03.100Z" />
