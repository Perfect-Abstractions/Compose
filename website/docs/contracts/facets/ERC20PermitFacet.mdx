---
sidebar_position: 99
title: "ERC20PermitFacet"
description: "ERC-20 token permit facet for Compose diamonds"
gitSource: "https://github.com/maxnorm/Compose/blob/8fcbb812c7f4f59338db6b04ce17631a729a30f9/src/token/ERC20/ERC20Permit/ERC20PermitFacet.sol"
---

import DocSubtitle  from '@site/src/components/docs/DocSubtitle';
import Badge from '@site/src/components/ui/Badge';
import Callout from '@site/src/components/ui/Callout';
import CalloutBox from '@site/src/components/ui/CalloutBox';
import Accordion, { AccordionGroup } from '@site/src/components/ui/Accordion';
import PropertyTable from '@site/src/components/api/PropertyTable';
import ExpandableCode from '@site/src/components/code/ExpandableCode';
import CodeShowcase from '@site/src/components/code/CodeShowcase';
import RelatedDocs from '@site/src/components/docs/RelatedDocs';
import WasThisHelpful from '@site/src/components/docs/WasThisHelpful';
import LastUpdated from '@site/src/components/docs/LastUpdated';
import ReadingTime from '@site/src/components/docs/ReadingTime';
import GradientText from '@site/src/components/ui/GradientText';
import GradientButton from '@site/src/components/ui/GradientButton';

<DocSubtitle>
ERC-20 token permit facet for Compose diamonds
</DocSubtitle>

<Callout type="info" title="Key Features">
- Implements EIP-2612 for gasless token approvals via signatures.
- Provides `nonces` and `DOMAIN_SEPARATOR` for signature generation and validation.
- Allows setting token allowances without requiring a separate `approve` transaction.
</Callout>

## Overview

The ERC20PermitFacet enables EIP-2612 compliant token transfers within a Compose diamond. It provides the necessary functions to manage nonces, retrieve the domain separator, and execute token allowances via signed messages, enhancing user experience by removing the need for separate approval transactions.

---

## Storage

### ERC20Storage

<ExpandableCode language="solidity" maxLines={15} title="Definition">
{`struct ERC20Storage {
    mapping(address owner => uint256 balance) balanceOf;
    uint256 totalSupply;
    mapping(address owner => mapping(address spender => uint256 allowance)) allowance;
    uint8 decimals;
    string name;
}`}
</ExpandableCode>

---
### ERC20PermitStorage

<ExpandableCode language="solidity" maxLines={15} title="Definition">
{`struct ERC20PermitStorage {
    mapping(address owner => uint256) nonces;
}`}
</ExpandableCode>

### State Variables

<PropertyTable
  properties={[
    {
      name: "ERC20_STORAGE_POSITION",
      type: "constant",
      description: "Diamond storage slot position for this module"
    },
    {
      name: "STORAGE_POSITION",
      type: "constant",
      description: "Diamond storage slot position for this module"
    }
  ]}
  showRequired={false}
/>

## Functions

### getERC20Storage

<ExpandableCode language="solidity" maxLines={8}>
{`function getERC20Storage() internal pure returns (ERC20Storage storage s);`}
</ExpandableCode>

---
### getStorage

<ExpandableCode language="solidity" maxLines={8}>
{`function getStorage() internal pure returns (ERC20PermitStorage storage s);`}
</ExpandableCode>

---
### nonces

Returns the current nonce for an owner. This value changes each time a permit is used.

<ExpandableCode language="solidity" maxLines={8}>
{`function nonces(address _owner) external view returns (uint256);`}
</ExpandableCode>

**Parameters:**

<PropertyTable
  properties={[
    {
      name: "_owner",
      type: "address",
      description: "The address of the owner."
    }
  ]}
  showRequired={false}
/>

**Returns:**

<PropertyTable
  properties={[
    {
      name: "-",
      type: "uint256",
      description: "The current nonce."
    }
  ]}
  showRequired={false}
/>

---
### DOMAIN_SEPARATOR

Returns the domain separator used in the encoding of the signature for permit. This value is unique to a contract and chain ID combination to prevent replay attacks.

<ExpandableCode language="solidity" maxLines={8}>
{`function DOMAIN_SEPARATOR() external view returns (bytes32);`}
</ExpandableCode>

**Returns:**

<PropertyTable
  properties={[
    {
      name: "-",
      type: "bytes32",
      description: "The domain separator."
    }
  ]}
  showRequired={false}
/>

---
### permit

Sets the allowance for a spender via a signature. This function implements EIP-2612 permit functionality.

<ExpandableCode language="solidity" maxLines={8}>
{`function permit(
    address _owner,
    address _spender,
    uint256 _value,
    uint256 _deadline,
    uint8 _v,
    bytes32 _r,
    bytes32 _s
) external;`}
</ExpandableCode>

**Parameters:**

<PropertyTable
  properties={[
    {
      name: "_owner",
      type: "address",
      description: "The address of the token owner."
    },
    {
      name: "_spender",
      type: "address",
      description: "The address of the spender."
    },
    {
      name: "_value",
      type: "uint256",
      description: "The amount of tokens to approve."
    },
    {
      name: "_deadline",
      type: "uint256",
      description: "The deadline for the permit (timestamp)."
    },
    {
      name: "_v",
      type: "uint8",
      description: "The recovery byte of the signature."
    },
    {
      name: "_r",
      type: "bytes32",
      description: "The r value of the signature."
    },
    {
      name: "_s",
      type: "bytes32",
      description: "The s value of the signature."
    }
  ]}
  showRequired={false}
/>

## Events

<AccordionGroup>
  <Accordion title="Approval" defaultOpen={false}>
    <div style={{marginBottom: "1rem"}}>
      Emitted when an approval is made for a spender by an owner.
    </div>

    <div style={{marginBottom: "1rem"}}>
      <strong>Signature:</strong>
      <ExpandableCode language="solidity" maxLines={5}>
{`event Approval(address indexed _owner, address indexed _spender, uint256 _value);`}
      </ExpandableCode>
    </div>

    <div style={{marginBottom: "1rem"}}>
      <strong>Parameters:</strong>
      <PropertyTable
        properties={[
          {
            name: "_owner",
            type: "address",
            description: "The address granting the allowance."
          },
          {
            name: "_spender",
            type: "address",
            description: "The address receiving the allowance."
          },
          {
            name: "_value",
            type: "uint256",
            description: "The amount approved."
          }
        ]}
        showRequired={false}
      />
    </div>
  </Accordion>
</AccordionGroup>

## Errors

<AccordionGroup>
  <Accordion title="ERC2612InvalidSignature" defaultOpen={false}>
    <div style={{marginBottom: "1rem"}}>
      Thrown when a permit signature is invalid or expired.
    </div>

    <div>
      <strong>Signature:</strong>
      <ExpandableCode language="solidity" maxLines={5}>
error ERC2612InvalidSignature(
    address _owner, address _spender, uint256 _value, uint256 _deadline, uint8 _v, bytes32 _r, bytes32 _s
);
      </ExpandableCode>
    </div>
  </Accordion>
  <Accordion title="ERC20InvalidSpender" defaultOpen={false}>
    <div style={{marginBottom: "1rem"}}>
      Thrown when the spender address is invalid (e.g., zero address).
    </div>

    <div>
      <strong>Signature:</strong>
      <ExpandableCode language="solidity" maxLines={5}>
error ERC20InvalidSpender(address _spender);
      </ExpandableCode>
    </div>
  </Accordion>
</AccordionGroup>

## Usage Example

<ExpandableCode language="solidity" maxLines={20} title="Example Implementation">
{`pragma solidity ^0.8.30;

import {ERC20PermitFacet} from "@compose/facets/ERC20PermitFacet.sol";
import {DiamondProxy, DiamondInit} from "@compose/core/";

contract MyDiamondInit is DiamondInit {
    function init() public override {
        // ... other initializations ...
        ERC20PermitFacet.addFacet(msg.sender);
    }
}

contract MyDiamond is DiamondProxy {
    using ERC20PermitFacet for ERC20PermitFacet;

    function getERC20PermitFacet() public pure returns (ERC20PermitFacet) {
        return ERC20PermitFacet(address(this));
    }

    // Example of calling permit
    function permitToken(address owner, address spender, uint256 value, uint256 deadline, bytes calldata signature) external {
        // Assuming the ERC20 token contract is accessible via the diamond
        // You would typically have an ERC20Facet or similar to interact with the token
        // For demonstration, we call permit directly on the facet instance
        getERC20PermitFacet().permit(owner, spender, value, deadline, signature);
    }
}`}
</ExpandableCode>

## Best Practices

<Callout type="tip" title="Best Practice">
- Initialize the `ERC20PermitFacet` during diamond deployment using an `IDiamondInit` contract.
- Ensure the underlying ERC-20 token contract is correctly configured and accessible through the diamond's routing.
- Implement robust signature verification logic in off-chain or consumer contracts before submitting permit calls to the diamond.
</Callout>

## Security Considerations

<Callout type="warning" title="Security">
The `permit` function is susceptible to replay attacks if the `DOMAIN_SEPARATOR` is not properly constructed or if signatures are reused across different chains or diamond instances. Ensure the `deadline` parameter is used to limit the validity of permits. The `nonces` must be managed correctly to prevent signature reuse. Access control for calling `permit` should be considered based on the diamond's overall authorization strategy.
</Callout>

<div style={{marginTop: "3rem", paddingTop: "2rem", borderTop: "1px solid var(--ifm-color-emphasis-200)"}}>
  <WasThisHelpful pageId="ERC20PermitFacet" />
</div>

<LastUpdated date="2025-12-20T02:02:46.313Z" />
