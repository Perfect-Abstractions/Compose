---
sidebar_position: 99
title: "ERC20BurnFacet"
description: "ERC-20 token burn facet for Compose diamonds"
gitSource: "https://github.com/maxnorm/Compose/blob/4f58223f08f652d9b72a6792643c40cac4f0f4a0/src/token/ERC20/ERC20/ERC20BurnFacet.sol"
---

import DocSubtitle  from '@site/src/components/docs/DocSubtitle';
import Badge from '@site/src/components/ui/Badge';
import Callout from '@site/src/components/ui/Callout';
import CalloutBox from '@site/src/components/ui/CalloutBox';
import Accordion, { AccordionGroup } from '@site/src/components/ui/Accordion';
import PropertyTable from '@site/src/components/api/PropertyTable';
import ExpandableCode from '@site/src/components/code/ExpandableCode';
import CodeShowcase from '@site/src/components/code/CodeShowcase';
import RelatedDocs from '@site/src/components/docs/RelatedDocs';
import WasThisHelpful from '@site/src/components/docs/WasThisHelpful';
import LastUpdated from '@site/src/components/docs/LastUpdated';
import ReadingTime from '@site/src/components/docs/ReadingTime';
import GradientText from '@site/src/components/ui/GradientText';
import GradientButton from '@site/src/components/ui/GradientButton';

<DocSubtitle>
ERC-20 token burn facet for Compose diamonds
</DocSubtitle>

<Callout type="info" title="Key Features">
- Supports burning tokens from the caller's balance (`burn`).
- Supports burning tokens from another account's balance, respecting allowances (`burnFrom`).
- Integrates with the Compose diamond storage pattern for ERC-20 state management.
</Callout>

## Overview

The ERC20BurnFacet provides functionality to burn ERC-20 tokens within a Compose diamond. It allows users to destroy tokens from their own balance or from another account's balance, reducing the total supply. This facet integrates seamlessly with the diamond's storage pattern for managing ERC-20 state.

---

## Storage

### ERC20Storage

<ExpandableCode language="solidity" maxLines={15} title="Definition">
{`struct ERC20Storage {
    mapping(address owner => uint256 balance) balanceOf;
    uint256 totalSupply;
    mapping(address owner => mapping(address spender => uint256 allowance)) allowance;
}`}
</ExpandableCode>

---
### State Variables

<PropertyTable
  properties={[
    {
      name: "STORAGE_POSITION",
      type: "constant",
      description: "Diamond storage slot position for this module"
    }
  ]}
  showRequired={false}
/>

## Functions

### getStorage

Returns the ERC20 storage struct from the predefined diamond storage slot. Uses inline assembly to set the storage slot reference.

<ExpandableCode language="solidity" maxLines={8}>
{`function getStorage() internal pure returns (ERC20Storage storage s);`}
</ExpandableCode>

**Returns:**

<PropertyTable
  properties={[
    {
      name: "s",
      type: "ERC20Storage",
      description: "The ERC20 storage struct reference."
    }
  ]}
  showRequired={false}
/>

---
### burn

Burns (destroys) a specific amount of tokens from the caller's balance. Emits a Transfer event to the zero address.

<ExpandableCode language="solidity" maxLines={8}>
{`function burn(uint256 _value) external;`}
</ExpandableCode>

**Parameters:**

<PropertyTable
  properties={[
    {
      name: "_value",
      type: "uint256",
      description: "The amount of tokens to burn."
    }
  ]}
  showRequired={false}
/>

---
### burnFrom

Burns tokens from another account, deducting from the caller's allowance. Emits a Transfer event to the zero address.

<ExpandableCode language="solidity" maxLines={8}>
{`function burnFrom(address _account, uint256 _value) external;`}
</ExpandableCode>

**Parameters:**

<PropertyTable
  properties={[
    {
      name: "_account",
      type: "address",
      description: "The address whose tokens will be burned."
    },
    {
      name: "_value",
      type: "uint256",
      description: "The amount of tokens to burn."
    }
  ]}
  showRequired={false}
/>

## Events

<AccordionGroup>
  <Accordion title="Transfer" defaultOpen={false}>
    <div style={{marginBottom: "1rem"}}>
      Emitted when tokens are transferred between two addresses.
    </div>

    <div style={{marginBottom: "1rem"}}>
      <strong>Signature:</strong>
      <ExpandableCode language="solidity" maxLines={5}>
{`event Transfer(address indexed _from, address indexed _to, uint256 _value);`}
      </ExpandableCode>
    </div>

    <div style={{marginBottom: "1rem"}}>
      <strong>Parameters:</strong>
      <PropertyTable
        properties={[
          {
            name: "_from",
            type: "address",
            description: "Address sending the tokens."
          },
          {
            name: "_to",
            type: "address",
            description: "Address receiving the tokens."
          },
          {
            name: "_value",
            type: "uint256",
            description: "Amount of tokens transferred."
          }
        ]}
        showRequired={false}
      />
    </div>
  </Accordion>
</AccordionGroup>

## Errors

<AccordionGroup>
  <Accordion title="ERC20InsufficientBalance" defaultOpen={false}>
    <div style={{marginBottom: "1rem"}}>
      Thrown when an account has insufficient balance for a transfer or burn.
    </div>

    <div>
      <strong>Signature:</strong>
      <ExpandableCode language="solidity" maxLines={5}>
error ERC20InsufficientBalance(address _sender, uint256 _balance, uint256 _needed);
      </ExpandableCode>
    </div>
  </Accordion>
  <Accordion title="ERC20InsufficientAllowance" defaultOpen={false}>
    <div style={{marginBottom: "1rem"}}>
      Thrown when a spender tries to use more than the approved allowance.
    </div>

    <div>
      <strong>Signature:</strong>
      <ExpandableCode language="solidity" maxLines={5}>
error ERC20InsufficientAllowance(address _spender, uint256 _allowance, uint256 _needed);
      </ExpandableCode>
    </div>
  </Accordion>
</AccordionGroup>

## Usage Example

<ExpandableCode language="solidity" maxLines={20} title="Example Implementation">
{`pragma solidity ^0.8.30;

import {IERC20BurnFacet} from "../facets/ERC20BurnFacet.sol";
import {IDiamondCut} from "@compose/diamond-protocol/contracts/interfaces/IDiamondCut.sol";

contract ERC20BurnFacetDeployment {
    address constant DIAMOND_STORAGE_SLOT = address(uint160(uint256(keccak256("diamond.storage.erc20"))));

    function deployERC20BurnFacet() public returns (address facet) {
        facet = address(new ERC20BurnFacet());

        // Example: Add ERC20BurnFacet to the diamond
        // IDiamondCut(diamondAddress).diamondCut(diamondCutCalldata, address(0), "");

        return facet;
    }

    // Example: Calling burnFrom
    function burnSomeTokens(address diamondAddress, address _spender, address _from, uint256 _amount) public {
        bytes4 selector = IERC20BurnFacet.burnFrom.selector;

        // Calldata for burnFrom
        bytes memory data = abi.encodeWithSelector(selector, _from, _amount);

        // Assuming _spender has an allowance from _from
        // Call the diamond proxy to execute burnFrom
        (bool success, bytes memory returnData) = diamondAddress.call(data);
        require(success, "Burn failed");
    }
}`}
</ExpandableCode>

## Best Practices

<Callout type="tip" title="Best Practice">
- Initialize the ERC20BurnFacet with the correct diamond storage slot address during deployment.
- Ensure the caller has sufficient allowance if using `burnFrom`.
- Access the facet through the diamond proxy address for all interactions.
</Callout>

## Security Considerations

<Callout type="warning" title="Security">
The `burn` function is permissionless and reduces total supply. The `burnFrom` function requires proper allowance management to prevent unintended token burning. Ensure the diamond's access control mechanisms are correctly configured for any administrative functions related to token supply if applicable.
</Callout>

<div style={{marginTop: "3rem", paddingTop: "2rem", borderTop: "1px solid var(--ifm-color-emphasis-200)"}}>
  <WasThisHelpful pageId="ERC20BurnFacet" />
</div>

<LastUpdated date="2025-12-19T22:46:06.219Z" />
