---
sidebar_position: 99
title: "ERC721BurnFacet"
description: "**Title:**"
gitSource: "https://github.com/maxnorm/Compose/blob/7cec432f52f2cad53f4d546df90deb49e6a66d41/src/token/ERC721/ERC721/ERC721BurnFacet.sol"
---

import DocSubtitle  from '@site/src/components/docs/DocSubtitle';
import Badge from '@site/src/components/ui/Badge';
import Callout from '@site/src/components/ui/Callout';
import CalloutBox from '@site/src/components/ui/CalloutBox';
import Accordion, { AccordionGroup } from '@site/src/components/ui/Accordion';
import PropertyTable from '@site/src/components/api/PropertyTable';
import ExpandableCode from '@site/src/components/code/ExpandableCode';
import CodeShowcase from '@site/src/components/code/CodeShowcase';
import RelatedDocs from '@site/src/components/docs/RelatedDocs';
import WasThisHelpful from '@site/src/components/docs/WasThisHelpful';
import LastUpdated from '@site/src/components/docs/LastUpdated';
import ReadingTime from '@site/src/components/docs/ReadingTime';
import GradientText from '@site/src/components/ui/GradientText';
import GradientButton from '@site/src/components/ui/GradientButton';

<DocSubtitle>
**Title:**
</DocSubtitle>

<Callout type="info" title="Key Features">
- Enables the irreversible destruction of ERC-721 tokens.
- Integrates seamlessly with the Compose diamond storage pattern.
- Provides a clear interface for token burning operations.
</Callout>

## Overview

The ERC721BurnFacet provides the functionality to burn (destroy) ERC-721 tokens within a Compose diamond. It allows for the removal of tokens from tracking and enumeration, reducing the total supply and freeing up associated metadata. This facet interacts directly with the diamond&#x27;s storage to manage token states.

---

## Storage

### ERC721Storage

<ExpandableCode language="solidity" maxLines={15} title="Definition">
{`struct ERC721Storage {
    mapping(uint256 tokenId => address owner) ownerOf;
    mapping(address owner => uint256 balance) balanceOf;
    mapping(address owner => mapping(address operator => bool approved)) isApprovedForAll;
    mapping(uint256 tokenId => address approved) approved;
}`}
</ExpandableCode>

---
### State Variables

<PropertyTable
  properties={[
    {
      name: "STORAGE_POSITION",
      type: "constant",
      description: ""
    }
  ]}
  showRequired={false}
/>

## Functions

### getStorage

Returns a pointer to the ERC-721 storage struct. Uses inline assembly to access the storage slot defined by STORAGE_POSITION.

<ExpandableCode language="solidity" maxLines={8}>
{`function getStorage() internal pure returns (ERC721Storage storage s);`}
</ExpandableCode>

**Returns:**

<PropertyTable
  properties={[
    {
      name: "s",
      type: "ERC721Storage",
      description: "The ERC721Storage struct in storage."
    }
  ]}
  showRequired={false}
/>

---
### burn

Burns (destroys) a token, removing it from enumeration tracking.

<ExpandableCode language="solidity" maxLines={8}>
{`function burn(uint256 _tokenId) external;`}
</ExpandableCode>

**Parameters:**

<PropertyTable
  properties={[
    {
      name: "_tokenId",
      type: "uint256",
      description: "The ID of the token to burn."
    }
  ]}
  showRequired={false}
/>

## Events

<AccordionGroup>
  <Accordion title="Transfer" defaultOpen={false}>

    <div style={{marginBottom: "1rem"}}>
      <strong>Signature:</strong>
      <ExpandableCode language="solidity" maxLines={5}>
{`event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);`}
      </ExpandableCode>
    </div>

  </Accordion>
  <Accordion title="Approval" defaultOpen={false}>

    <div style={{marginBottom: "1rem"}}>
      <strong>Signature:</strong>
      <ExpandableCode language="solidity" maxLines={5}>
{`event Approval(address indexed _owner, address indexed _to, uint256 indexed _tokenId);`}
      </ExpandableCode>
    </div>

  </Accordion>
  <Accordion title="ApprovalForAll" defaultOpen={false}>

    <div style={{marginBottom: "1rem"}}>
      <strong>Signature:</strong>
      <ExpandableCode language="solidity" maxLines={5}>
{`event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);`}
      </ExpandableCode>
    </div>

  </Accordion>
</AccordionGroup>

## Errors

<AccordionGroup>
  <Accordion title="ERC721NonexistentToken" defaultOpen={false}>

    <div>
      <strong>Signature:</strong>
      <ExpandableCode language="solidity" maxLines={5}>
error ERC721NonexistentToken(uint256 _tokenId);
      </ExpandableCode>
    </div>
  </Accordion>
  <Accordion title="ERC721InsufficientApproval" defaultOpen={false}>

    <div>
      <strong>Signature:</strong>
      <ExpandableCode language="solidity" maxLines={5}>
error ERC721InsufficientApproval(address _operator, uint256 _tokenId);
      </ExpandableCode>
    </div>
  </Accordion>
</AccordionGroup>

## Usage Example

<ExpandableCode language="solidity" maxLines={20} title="Example Implementation">
{`pragma solidity ^0.8.30;

import {IERC721BurnFacet} from "@compose/contracts/src/facets/erc721/ERC721BurnFacet.sol";
import {IDiamondCut} from "@compose/contracts/src/interfaces/IDiamondCut.sol";

contract Deployer {
    address constant ERC721_BURN_FACET_ADDRESS = address(0xABC); // Replace with actual facet address
    address constant DIAMOND_ADDRESS = address(0xDEF); // Replace with actual diamond address

    function deploy() external {
        IDiamondCut(DIAMOND_ADDRESS).diamondCut(
            IDiamondCut.FacetCut[](
                (IDiamondCut.FacetCut({
                    facetAddress: ERC721_BURN_FACET_ADDRESS,
                    action: IDiamondCut.FacetCutAction.ADD,
                    selectors:
                        bytes4(keccak256("burn(uint256)"))    |
                        bytes4(keccak256("getStorage()\0x1a2b3c4d")) // Example selector, replace with actual
                }))
            ),
            address(0), // Initialize facetAddresses (optional)
            bytes("")     // Initialize facetCalldata (optional)
        );
    }

    function burnToken(uint256 tokenId) external {
        IERC721BurnFacet(DIAMOND_ADDRESS).burn(tokenId);
    }
}`}
</ExpandableCode>

## Best Practices

<Callout type="tip" title="Best Practice">
- Ensure the &#x60;ERC721BurnFacet&#x60; is added to the diamond with the correct selectors during deployment or upgrade.
- Implement proper access control mechanisms within your diamond&#x27;s governance to restrict who can call the &#x60;burn&#x60; function, if necessary.
- Understand that burning a token is irreversible; ensure user intent is validated before execution.
</Callout>

## Security Considerations

<Callout type="warning" title="Security">
The &#x60;burn&#x60; function should be protected by appropriate access control to prevent unauthorized token destruction. The facet directly manipulates internal storage, so ensure its integration does not conflict with other facets managing token states or ownership. Reentrancy is not a concern as the function does not make external calls. Input validation on &#x60;tokenId&#x60; is crucial to prevent unexpected behavior.
</Callout>

<div style={{marginTop: "3rem", paddingTop: "2rem", borderTop: "1px solid var(--ifm-color-emphasis-200)"}}>
  <WasThisHelpful pageId="ERC721BurnFacet" />
</div>

<LastUpdated date="2025-12-19T21:23:27.884Z" />
