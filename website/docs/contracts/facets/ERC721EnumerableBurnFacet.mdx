---
sidebar_position: 99
title: "ERC721EnumerableBurnFacet"
description: "ERC-721 NFT enumerableburn facet for Compose diamonds"
gitSource: "https://github.com/maxnorm/Compose/blob/4f58223f08f652d9b72a6792643c40cac4f0f4a0/src/token/ERC721/ERC721Enumerable/ERC721EnumerableBurnFacet.sol"
---

import DocSubtitle  from '@site/src/components/docs/DocSubtitle';
import Badge from '@site/src/components/ui/Badge';
import Callout from '@site/src/components/ui/Callout';
import CalloutBox from '@site/src/components/ui/CalloutBox';
import Accordion, { AccordionGroup } from '@site/src/components/ui/Accordion';
import PropertyTable from '@site/src/components/api/PropertyTable';
import ExpandableCode from '@site/src/components/code/ExpandableCode';
import CodeShowcase from '@site/src/components/code/CodeShowcase';
import RelatedDocs from '@site/src/components/docs/RelatedDocs';
import WasThisHelpful from '@site/src/components/docs/WasThisHelpful';
import LastUpdated from '@site/src/components/docs/LastUpdated';
import ReadingTime from '@site/src/components/docs/ReadingTime';
import GradientText from '@site/src/components/ui/GradientText';
import GradientButton from '@site/src/components/ui/GradientButton';

<DocSubtitle>
ERC-721 NFT enumerableburn facet for Compose diamonds
</DocSubtitle>

<Callout type="info" title="Key Features">
- Enables burning of ERC721 tokens directly on the diamond.
- Maintains internal token enumeration integrity after token destruction.
- Provides access to the facet's internal storage layout for advanced use cases.
</Callout>

## Overview

The ERC721EnumerableBurnFacet extends ERC721 functionality by providing the ability to burn NFTs while maintaining enumeration tracking. It allows for the removal of tokens from the diamond's state and ensures that the internal token lists remain consistent.

---

## Storage

### ERC721EnumerableStorage

<ExpandableCode language="solidity" maxLines={15} title="Definition">
{`struct ERC721EnumerableStorage {
    mapping(uint256 tokenId => address owner) ownerOf;
    mapping(address owner => uint256[] ownerTokens) ownerTokens;
    mapping(uint256 tokenId => uint256 ownerTokensIndex) ownerTokensIndex;
    uint256[] allTokens;
    mapping(uint256 tokenId => uint256 allTokensIndex) allTokensIndex;
    mapping(address owner => mapping(address operator => bool approved)) isApprovedForAll;
    mapping(uint256 tokenId => address approved) approved;
}`}
</ExpandableCode>

---
### State Variables

<PropertyTable
  properties={[
    {
      name: "STORAGE_POSITION",
      type: "constant",
      description: "Diamond storage slot position for this module"
    }
  ]}
  showRequired={false}
/>

## Functions

### getStorage

Returns the storage struct used by this facet.

<ExpandableCode language="solidity" maxLines={8}>
{`function getStorage() internal pure returns (ERC721EnumerableStorage storage s);`}
</ExpandableCode>

**Returns:**

<PropertyTable
  properties={[
    {
      name: "s",
      type: "ERC721EnumerableStorage",
      description: "The ERC721Enumerable storage struct."
    }
  ]}
  showRequired={false}
/>

---
### burn

Burns (destroys) a token, removing it from enumeration tracking.

<ExpandableCode language="solidity" maxLines={8}>
{`function burn(uint256 _tokenId) external;`}
</ExpandableCode>

**Parameters:**

<PropertyTable
  properties={[
    {
      name: "_tokenId",
      type: "uint256",
      description: "The ID of the token to burn."
    }
  ]}
  showRequired={false}
/>

## Events

<AccordionGroup>
  <Accordion title="Transfer" defaultOpen={false}>
    <div style={{marginBottom: "1rem"}}>
      Emitted when ownership of a token changes, including burning.
    </div>

    <div style={{marginBottom: "1rem"}}>
      <strong>Signature:</strong>
      <ExpandableCode language="solidity" maxLines={5}>
{`event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);`}
      </ExpandableCode>
    </div>

    <div style={{marginBottom: "1rem"}}>
      <strong>Parameters:</strong>
      <PropertyTable
        properties={[
          {
            name: "_from",
            type: "address",
            description: "The address transferring the token (or owner when burning)."
          },
          {
            name: "_to",
            type: "address",
            description: "The address receiving the token (zero address when burning)."
          },
          {
            name: "_tokenId",
            type: "uint256",
            description: "The ID of the token being transferred."
          }
        ]}
        showRequired={false}
      />
    </div>
  </Accordion>
</AccordionGroup>

## Errors

<AccordionGroup>
  <Accordion title="ERC721NonexistentToken" defaultOpen={false}>
    <div style={{marginBottom: "1rem"}}>
      Thrown when attempting to interact with a non-existent token.
    </div>

    <div>
      <strong>Signature:</strong>
      <ExpandableCode language="solidity" maxLines={5}>
error ERC721NonexistentToken(uint256 _tokenId);
      </ExpandableCode>
    </div>
  </Accordion>
  <Accordion title="ERC721InsufficientApproval" defaultOpen={false}>
    <div style={{marginBottom: "1rem"}}>
      Thrown when the caller lacks approval to operate on the token.
    </div>

    <div>
      <strong>Signature:</strong>
      <ExpandableCode language="solidity" maxLines={5}>
error ERC721InsufficientApproval(address _operator, uint256 _tokenId);
      </ExpandableCode>
    </div>
  </Accordion>
</AccordionGroup>

## Usage Example

<ExpandableCode language="solidity" maxLines={20} title="Example Implementation">
{`pragma solidity ^0.8.30;

import {DiamondProxy} from "@compose-protocol/diamond-proxy/contracts/DiamondProxy.sol";
import {IERC721EnumerableBurnFacet} from "./interfaces/IERC721EnumerableBurnFacet.sol";

contract Deployer {
    function deploy() external {
        // Assume diamondProxy is an already deployed DiamondProxy instance
        DiamondProxy diamondProxy;

        // Get the facet implementation address (replace with actual deployment logic)
        address erc721EnumerableBurnFacetImpl = address(0x...');

        // Add the facet to the diamond
        // (Requires DiamondCutFacet to be accessible and authorized)
        // diamondProxy.diamondCut(...);

        // Interact with the facet through the diamond proxy
        IERC721EnumerableBurnFacet enumerableBurnFacet = IERC721EnumerableBurnFacet(diamondProxy);

        // Example: Burn token ID 1
        address from = msg.sender;
        uint256 tokenId = 1;
        enumerableBurnFacet.burn(from, tokenId);
    }
}`}
</ExpandableCode>

## Best Practices

<Callout type="tip" title="Best Practice">
- Ensure the ERC721EnumerableBurnFacet is correctly added to the diamond via a `diamondCut` operation before attempting to use its functions.
- The `burn` function requires the caller to be the owner of the token or an approved address, adhering to standard ERC721 authorization rules.
- Access the facet's storage struct using the `getStorage` function for introspection or debugging if necessary.
</Callout>

## Security Considerations

<Callout type="warning" title="Security">
The `burn` function must enforce standard ERC721 ownership and approval checks to prevent unauthorized token destruction. Ensure that the diamond's access control mechanisms correctly delegate calls to this facet. Reentrancy is not a direct concern for the `burn` function itself, as it primarily modifies state and does not make external calls.
</Callout>

<div style={{marginTop: "3rem", paddingTop: "2rem", borderTop: "1px solid var(--ifm-color-emphasis-200)"}}>
  <WasThisHelpful pageId="ERC721EnumerableBurnFacet" />
</div>

<LastUpdated date="2025-12-19T22:46:37.777Z" />
