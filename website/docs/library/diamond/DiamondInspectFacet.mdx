---
sidebar_position: 99
title: "DiamondInspectFacet"
description: "Inspect diamond storage and facet mappings."
gitSource: "https://github.com/Perfect-Abstractions/Compose/tree/main/src/diamond/DiamondInspectFacet.sol"
---

import DocSubtitle  from '@site/src/components/docs/DocSubtitle';
import Badge from '@site/src/components/ui/Badge';
import Callout from '@site/src/components/ui/Callout';
import CalloutBox from '@site/src/components/ui/CalloutBox';
import Accordion, { AccordionGroup } from '@site/src/components/ui/Accordion';
import PropertyTable from '@site/src/components/api/PropertyTable';
import ExpandableCode from '@site/src/components/code/ExpandableCode';
import CodeShowcase from '@site/src/components/code/CodeShowcase';
import RelatedDocs from '@site/src/components/docs/RelatedDocs';
import WasThisHelpful from '@site/src/components/docs/WasThisHelpful';
import LastUpdated from '@site/src/components/docs/LastUpdated';
import ReadingTime from '@site/src/components/docs/ReadingTime';
import GradientText from '@site/src/components/ui/GradientText';
import GradientButton from '@site/src/components/ui/GradientButton';

<DocSubtitle>
Inspect diamond storage and facet mappings.
</DocSubtitle>

<Callout type="info" title="Key Features">
- Provides read-only access to diamond's internal storage.
- Maps all registered function selectors to their implementation facet addresses.
- Facilitates external auditing and debugging of diamond deployments.
</Callout>

## Overview

The DiamondInspectFacet provides essential read-only capabilities to query the internal state of a Compose diamond. It allows developers to retrieve the diamond's storage layout and map function selectors to their respective implementation facets, crucial for debugging and understanding diamond composition.

---

## Storage

### FacetAndPosition

<ExpandableCode language="solidity" maxLines={15} title="Definition">
{`struct FacetAndPosition {
    address facet;
    uint32 position;
}`}
</ExpandableCode>

---
### DiamondStorage

<ExpandableCode language="solidity" maxLines={15} title="Definition">
{`struct DiamondStorage {
    mapping(bytes4 functionSelector => FacetAndPosition) facetAndPosition;
    /**
    * Array of all function selectors that can be called in the diamond.
    */
    bytes4[] selectors;
}`}
</ExpandableCode>

---
### FunctionFacetPair

<ExpandableCode language="solidity" maxLines={15} title="Definition">
{`struct FunctionFacetPair {
    bytes4 selector;
    address facet;
}`}
</ExpandableCode>

### State Variables

<PropertyTable
  properties={[
    {
      name: "DIAMOND_STORAGE_POSITION",
      type: "bytes32",
      description: "Diamond storage slot position for this module (Value: `keccak256(\"compose.diamond\")`)"
    }
  ]}
  showRequired={false}
/>

## Functions

### functionFacetPairs

Returns an array of all function selectors and their corresponding facet addresses. Iterates through the diamond's stored selectors and pairs each with its facet.

<ExpandableCode language="solidity" maxLines={8}>
{`function functionFacetPairs() external view returns (FunctionFacetPair[] memory pairs);`}
</ExpandableCode>

**Returns:**

<PropertyTable
  properties={[
    {
      name: "pairs",
      type: "FunctionFacetPair[]",
      description: "An array of `FunctionFacetPair` structs, each containing a selector and its facet address."
    }
  ]}
  showRequired={false}
/>

## Usage Example

<ExpandableCode language="solidity" maxLines={20} title="Example Implementation">
{`pragma solidity ^0.8.30;

import {IDiamondInspectFacet} from "@compose-protocol/diamond/contracts/facets/DiamondInspectFacet.sol";

contract DiamondConsumer {
    IDiamondInspectFacet immutable diamondInspect;

    constructor(address diamondAddress) {
        diamondInspect = IDiamondInspectFacet(diamondAddress);
    }

    function inspectDiamond() external view returns (bytes[] memory, (address, address)[]) {
        // In a real scenario, you would need to know the storage slot of the diamond storage struct.
        // For demonstration, we assume a known slot or a way to retrieve it.
        // bytes[] memory storageData = diamondInspect.getStorage(); // Hypothetical call if storage slot is known

        (address[] memory selectors, address[] memory facets) = diamondInspect.functionFacetPairs();

        bytes[] memory storageData = new bytes[](0); // Placeholder, getStorage requires knowledge of storage slot

        (address, address)[] memory pairs = new (address, address)[](selectors.length);
        for (uint i = 0; i < selectors.length; i++) {
            pairs[i] = (selectors[i], facets[i]);
        }

        return (storageData, pairs);
    }
}`}
</ExpandableCode>

## Best Practices

<Callout type="tip" title="Best Practice">
- Integrate this facet into your diamond to enable runtime inspection of its configuration and facet mappings.
- Use `functionFacetPairs` to verify which functions are routed to which facets during development and debugging.
- Understand that `getStorage` requires knowledge of the specific storage slot used for the diamond's storage struct, which is not exposed directly by this facet.
</Callout>

## Security Considerations

<Callout type="warning" title="Security">
This facet is read-only and does not modify state. Its primary security consideration is ensuring the integrity of the data it returns, which relies on the correct implementation of the diamond proxy and facet registration. Access control is not applicable as all functions are publicly viewable.
</Callout>

<div style={{marginTop: "3rem", paddingTop: "2rem", borderTop: "1px solid var(--ifm-color-emphasis-200)"}}>
  <WasThisHelpful pageId="DiamondInspectFacet" />
</div>

<LastUpdated date="2025-12-28T04:29:44.699Z" />
