---
sidebar_position: 99
title: "DiamondCutMod"
description: "Manages diamond facet additions, removals, and replacements."
gitSource: "https://github.com/maxnorm/Compose/blob/75e2e68f9cd44e6a24767abe937e3f91886c823f/src/diamond/DiamondCutMod.sol"
---

import DocSubtitle  from '@site/src/components/docs/DocSubtitle';
import Badge from '@site/src/components/ui/Badge';
import Callout from '@site/src/components/ui/Callout';
import CalloutBox from '@site/src/components/ui/CalloutBox';
import Accordion, { AccordionGroup } from '@site/src/components/ui/Accordion';
import PropertyTable from '@site/src/components/api/PropertyTable';
import ExpandableCode from '@site/src/components/code/ExpandableCode';
import CodeShowcase from '@site/src/components/code/CodeShowcase';
import RelatedDocs from '@site/src/components/docs/RelatedDocs';
import WasThisHelpful from '@site/src/components/docs/WasThisHelpful';
import LastUpdated from '@site/src/components/docs/LastUpdated';
import ReadingTime from '@site/src/components/docs/ReadingTime';
import GradientText from '@site/src/components/ui/GradientText';
import GradientButton from '@site/src/components/ui/GradientButton';

<DocSubtitle>
Manages diamond facet additions, removals, and replacements.
</DocSubtitle>

<Callout type="info" title="Key Features">
- Dynamically add, remove, or replace functions on the diamond proxy.
- Supports batch operations for multiple facet changes in a single transaction.
- Includes error handling for common issues like non-existent selectors or attempting to modify immutable functions.
</Callout>

<Callout type="info" title="Module Usage">
This module provides internal functions for use in your custom facets. Import it to access shared logic and storage.
</Callout>

## Overview

The DiamondCutMod provides essential functions for dynamically managing the facets attached to a Compose diamond. It allows for the addition of new functions, the removal of existing ones, and the replacement of functions with new implementations, all while ensuring the integrity and safety of the diamond's logic. This module is crucial for upgrading and evolving diamond functionality post-deployment.

---

## Storage

### FacetCutAction

Add=0, Replace=1, Remove=2

---
### DiamondStorage

storage-location: erc8042:compose.diamond

<ExpandableCode language="solidity" maxLines={15} title="Definition">
{`struct DiamondStorage {
mapping(bytes4 functionSelector => FacetAndPosition) facetAndPosition;
/**
 * Array of all function selectors that can be called in the diamond
 */
bytes4[] selectors;
}`}
</ExpandableCode>

---
### FacetAndPosition

<ExpandableCode language="solidity" maxLines={15} title="Definition">
{`struct FacetAndPosition {
address facet;
uint32 position;
}`}
</ExpandableCode>

---
### FacetCut

<ExpandableCode language="solidity" maxLines={15} title="Definition">
{`struct FacetCut {
address facetAddress;
FacetCutAction action;
bytes4[] functionSelectors;
}`}
</ExpandableCode>

### State Variables

<PropertyTable
  properties={[
    {
      name: "DIAMOND_STORAGE_POSITION",
      type: "bytes32",
      description: "Diamond storage slot position for this module (Value: `keccak256(\"compose.diamond\")`)"
    }
  ]}
  showRequired={false}
/>

## Functions

### addFunctions

<ExpandableCode language="solidity" maxLines={8}>
{`function addFunctions(address _facet, bytes4[] calldata _functionSelectors) ;`}
</ExpandableCode>

**Parameters:**

<PropertyTable
  properties={[
    {
      name: "_facet",
      type: "address",
      description: ""
    },
    {
      name: "_functionSelectors",
      type: "bytes4[]",
      description: ""
    }
  ]}
  showRequired={false}
/>

---
### diamondCut

Add/replace/remove any number of functions and optionally execute a function with delegatecall

<ExpandableCode language="solidity" maxLines={8}>
{`function diamondCut(FacetCut[] calldata _diamondCut, address _init, bytes calldata _calldata) ;`}
</ExpandableCode>

**Parameters:**

<PropertyTable
  properties={[
    {
      name: "_diamondCut",
      type: "FacetCut[]",
      description: "Contains the facet addresses and function selectors"
    },
    {
      name: "_init",
      type: "address",
      description: "The address of the contract or facet to execute _calldata"
    },
    {
      name: "_calldata",
      type: "bytes",
      description: "A function call, including function selector and arguments _calldata is executed with delegatecall on _init"
    }
  ]}
  showRequired={false}
/>

---
### getStorage

<ExpandableCode language="solidity" maxLines={8}>
{`function getStorage() pure returns (DiamondStorage storage s);`}
</ExpandableCode>

---
### removeFunctions

<ExpandableCode language="solidity" maxLines={8}>
{`function removeFunctions(address _facet, bytes4[] calldata _functionSelectors) ;`}
</ExpandableCode>

**Parameters:**

<PropertyTable
  properties={[
    {
      name: "_facet",
      type: "address",
      description: ""
    },
    {
      name: "_functionSelectors",
      type: "bytes4[]",
      description: ""
    }
  ]}
  showRequired={false}
/>

---
### replaceFunctions

<ExpandableCode language="solidity" maxLines={8}>
{`function replaceFunctions(address _facet, bytes4[] calldata _functionSelectors) ;`}
</ExpandableCode>

**Parameters:**

<PropertyTable
  properties={[
    {
      name: "_facet",
      type: "address",
      description: ""
    },
    {
      name: "_functionSelectors",
      type: "bytes4[]",
      description: ""
    }
  ]}
  showRequired={false}
/>

## Events

<AccordionGroup>
  <Accordion title="DiamondCut" defaultOpen={false}>

    <div style={{marginBottom: "1rem"}}>
      <strong>Signature:</strong>
      <ExpandableCode language="solidity" maxLines={5}>
{`event DiamondCut(FacetCut[] _diamondCut, address _init, bytes _calldata);`}
      </ExpandableCode>
    </div>

  </Accordion>
</AccordionGroup>

## Errors

<AccordionGroup>
  <Accordion title="CannotAddFunctionToDiamondThatAlreadyExists" defaultOpen={false}>

    <div>
      <strong>Signature:</strong>
      <ExpandableCode language="solidity" maxLines={5}>
error CannotAddFunctionToDiamondThatAlreadyExists(bytes4 _selector);
      </ExpandableCode>
    </div>
  </Accordion>
  <Accordion title="CannotRemoveFunctionThatDoesNotExist" defaultOpen={false}>

    <div>
      <strong>Signature:</strong>
      <ExpandableCode language="solidity" maxLines={5}>
error CannotRemoveFunctionThatDoesNotExist(bytes4 _selector);
      </ExpandableCode>
    </div>
  </Accordion>
  <Accordion title="CannotRemoveImmutableFunction" defaultOpen={false}>

    <div>
      <strong>Signature:</strong>
      <ExpandableCode language="solidity" maxLines={5}>
error CannotRemoveImmutableFunction(bytes4 _selector);
      </ExpandableCode>
    </div>
  </Accordion>
  <Accordion title="CannotReplaceFunctionThatDoesNotExists" defaultOpen={false}>

    <div>
      <strong>Signature:</strong>
      <ExpandableCode language="solidity" maxLines={5}>
error CannotReplaceFunctionThatDoesNotExists(bytes4 _selector);
      </ExpandableCode>
    </div>
  </Accordion>
  <Accordion title="CannotReplaceFunctionWithTheSameFunctionFromTheSameFacet" defaultOpen={false}>

    <div>
      <strong>Signature:</strong>
      <ExpandableCode language="solidity" maxLines={5}>
error CannotReplaceFunctionWithTheSameFunctionFromTheSameFacet(bytes4 _selector);
      </ExpandableCode>
    </div>
  </Accordion>
  <Accordion title="CannotReplaceImmutableFunction" defaultOpen={false}>

    <div>
      <strong>Signature:</strong>
      <ExpandableCode language="solidity" maxLines={5}>
error CannotReplaceImmutableFunction(bytes4 _selector);
      </ExpandableCode>
    </div>
  </Accordion>
  <Accordion title="IncorrectFacetCutAction" defaultOpen={false}>

    <div>
      <strong>Signature:</strong>
      <ExpandableCode language="solidity" maxLines={5}>
error IncorrectFacetCutAction(uint8 _action);
      </ExpandableCode>
    </div>
  </Accordion>
  <Accordion title="InitializationFunctionReverted" defaultOpen={false}>

    <div>
      <strong>Signature:</strong>
      <ExpandableCode language="solidity" maxLines={5}>
error InitializationFunctionReverted(address _initializationContractAddress, bytes _calldata);
      </ExpandableCode>
    </div>
  </Accordion>
  <Accordion title="NoBytecodeAtAddress" defaultOpen={false}>

    <div>
      <strong>Signature:</strong>
      <ExpandableCode language="solidity" maxLines={5}>
error NoBytecodeAtAddress(address _contractAddress, string _message);
      </ExpandableCode>
    </div>
  </Accordion>
  <Accordion title="NoSelectorsProvidedForFacet" defaultOpen={false}>

    <div>
      <strong>Signature:</strong>
      <ExpandableCode language="solidity" maxLines={5}>
error NoSelectorsProvidedForFacet(address _facet);
      </ExpandableCode>
    </div>
  </Accordion>
  <Accordion title="RemoveFacetAddressMustBeZeroAddress" defaultOpen={false}>

    <div>
      <strong>Signature:</strong>
      <ExpandableCode language="solidity" maxLines={5}>
error RemoveFacetAddressMustBeZeroAddress(address _facet);
      </ExpandableCode>
    </div>
  </Accordion>
</AccordionGroup>

## Usage Example

<ExpandableCode language="solidity" maxLines={20} title="Example Implementation">
{`pragma solidity ^0.8.30;

import {IDiamondCut} from "@compose/contracts/diamond/interfaces/IDiamondCut.sol";
import {DiamondCutMod} from "@compose/contracts/diamond/modules/DiamondCutMod.sol";

contract MyDiamondFacet {
    // Assume IDiamondCut is already implemented on the diamond
    IDiamondCut internal diamondCut = IDiamondCut(address(this));

    function upgradeMyFacet(address _newFacetAddress, bytes4[] memory _selectors) external {
        // Example: Replacing functions
        // Ensure _newFacetAddress is a valid facet contract
        // Ensure _selectors are the functions to be replaced from the old facet
        // and are present in the new facet.
        diamondCut.diamondCut(
            new IDiamondCut.FacetCut[]({
                IDiamondCut.FacetCut({
                    facetAddress: _newFacetAddress,
                    action: IDiamondCut.FacetCutAction.Replace,
                    selectors: _selectors
                })
            }),
            address(0), // No init function
            \"\" // No init data
        );
    }

    function addNewFunctionality(address _newFacetAddress, bytes4[] memory _selectors) external {
        diamondCut.diamondCut(
            new IDiamondCut.FacetCut[]({
                IDiamondCut.FacetCut({
                    facetAddress: _newFacetAddress,
                    action: IDiamondCut.FacetCutAction.Add,
                    selectors: _selectors
                })
            }),
            address(0),
            \"\"
        );
    }
}`}
</ExpandableCode>

## Best Practices

<Callout type="tip" title="Best Practice">
- Use `diamondCut` with `FacetCutAction.Replace` carefully, ensuring the new facet's selectors are compatible with the existing diamond logic to avoid breaking functionality.
- Always provide valid `selectors` when adding or replacing functions. An empty `selectors` array for `Add` actions will revert with `NoSelectorsProvidedForFacet`.
- Be aware of `Immutable` functions. Attempting to remove or replace them will revert with specific errors, preventing accidental modification of core diamond logic.
</Callout>

## Integration Notes

<Callout type="success" title="Shared Storage">
The `DiamondCutMod` interacts with the diamond's storage to manage the mapping of selectors to facet addresses. When functions are added, removed, or replaced, these changes are immediately reflected in the diamond's routing logic. Facets that interact with the diamond proxy should be aware that the underlying facet implementations can change. The `diamondCut` function can optionally execute an initialization function via `delegatecall` after the cut operation, allowing for state setup in new facets.
</Callout>

<div style={{marginTop: "3rem", paddingTop: "2rem", borderTop: "1px solid var(--ifm-color-emphasis-200)"}}>
  <WasThisHelpful pageId="DiamondCutMod" />
</div>

<LastUpdated date="2025-12-21T20:55:24.189Z" />
