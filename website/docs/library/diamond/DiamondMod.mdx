---
sidebar_position: 1
title: "DiamondMod"
description: "Manages facet additions and function dispatch for diamonds"
gitSource: "https://github.com/Perfect-Abstractions/Compose/tree/main/src/diamond/DiamondMod.sol"
---

import DocSubtitle  from '@site/src/components/docs/DocSubtitle';
import Badge from '@site/src/components/ui/Badge';
import Callout from '@site/src/components/ui/Callout';
import CalloutBox from '@site/src/components/ui/CalloutBox';
import Accordion, { AccordionGroup } from '@site/src/components/ui/Accordion';
import PropertyTable from '@site/src/components/api/PropertyTable';
import ExpandableCode from '@site/src/components/code/ExpandableCode';
import CodeShowcase from '@site/src/components/code/CodeShowcase';
import RelatedDocs from '@site/src/components/docs/RelatedDocs';
import WasThisHelpful from '@site/src/components/docs/WasThisHelpful';
import LastUpdated from '@site/src/components/docs/LastUpdated';
import ReadingTime from '@site/src/components/docs/ReadingTime';
import GradientText from '@site/src/components/ui/GradientText';
import GradientButton from '@site/src/components/ui/GradientButton';

<DocSubtitle>
Manages facet additions and function dispatch for diamonds
</DocSubtitle>

<Callout type="info" title="Key Features">
- Internal functions for facet management and call dispatch.
- Uses diamond storage pattern for centralized state.
- No external dependencies, promoting composability.
- Compatible with ERC-2535 diamond standard.
</Callout>

<Callout type="info" title="Module Usage">
This module provides internal functions for use in your custom facets. Import it to access shared logic and storage.
</Callout>

## Overview

This module provides internal functions for managing facets and dispatching calls within a diamond proxy. It enables composability by allowing facets to be added and functions to be routed to the correct implementation. Changes to facet mappings are managed internally, ensuring consistent function resolution across all interacting facets.

---

## Storage

### DiamondStorage

storage-location: erc8042:erc8109.diamond

<ExpandableCode language="solidity" maxLines={15} title="Definition">
{`struct DiamondStorage {
    mapping(bytes4 functionSelector => FacetAndPosition) facetAndPosition;
    /**
    * \`selectors\` contains all function selectors that can be called in the diamond.
    */
    bytes4[] selectors;
}`}
</ExpandableCode>

---
### FacetAndPosition

<ExpandableCode language="solidity" maxLines={15} title="Definition">
{`struct FacetAndPosition {
    address facet;
    uint32 position;
}`}
</ExpandableCode>

---
### FacetFunctions

<ExpandableCode language="solidity" maxLines={15} title="Definition">
{`struct FacetFunctions {
    address facet;
    bytes4[] selectors;
}`}
</ExpandableCode>

### State Variables

<PropertyTable
  properties={[
    {
      name: "DIAMOND_STORAGE_POSITION",
      type: "bytes32",
      description: "Diamond storage slot position for this module (Value: `keccak256(\"erc8109.diamond\")`)"
    }
  ]}
  showRequired={false}
/>

## Functions

### addFacets

Adds facets and their function selectors to the diamond. Only supports adding functions during diamond deployment.

<ExpandableCode language="solidity" maxLines={8}>
{`function addFacets(FacetFunctions[] memory _facets) ;`}
</ExpandableCode>

**Parameters:**

<PropertyTable
  properties={[
    {
      name: "_facets",
      type: "FacetFunctions[]",
      description: ""
    }
  ]}
  showRequired={false}
/>

---
### diamondFallback

Find facet for function that is called and execute the function if a facet is found and return any value.

<ExpandableCode language="solidity" maxLines={8}>
{`function diamondFallback() ;`}
</ExpandableCode>

---
### getStorage

<ExpandableCode language="solidity" maxLines={8}>
{`function getStorage() pure returns (DiamondStorage storage s);`}
</ExpandableCode>

## Events

<AccordionGroup>
  <Accordion title="DiamondFunctionAdded" defaultOpen={false}>
    <div style={{marginBottom: "1rem"}}>
      Emitted when a function is added to a diamond.
    </div>

    <div style={{marginBottom: "1rem"}}>
      <strong>Signature:</strong>
      <ExpandableCode language="solidity" maxLines={5}>
{`event DiamondFunctionAdded(bytes4 indexed _selector, address indexed _facet);`}
      </ExpandableCode>
    </div>

    <div style={{marginBottom: "1rem"}}>
      <strong>Parameters:</strong>
      <PropertyTable
        properties={[
          {
            name: "_selector",
            type: "bytes4",
            description: "The function selector being added."
          },
          {
            name: "_facet",
            type: "address",
            description: "The facet address that will handle calls to `_selector`."
          }
        ]}
        showRequired={false}
      />
    </div>
  </Accordion>
</AccordionGroup>

## Errors

<AccordionGroup>
  <Accordion title="CannotAddFunctionToDiamondThatAlreadyExists" defaultOpen={false}>

    <div>
      <strong>Signature:</strong>
      <ExpandableCode language="solidity" maxLines={5}>
error CannotAddFunctionToDiamondThatAlreadyExists(bytes4 _selector);
      </ExpandableCode>
    </div>
  </Accordion>
  <Accordion title="FunctionNotFound" defaultOpen={false}>

    <div>
      <strong>Signature:</strong>
      <ExpandableCode language="solidity" maxLines={5}>
error FunctionNotFound(bytes4 _selector);
      </ExpandableCode>
    </div>
  </Accordion>
  <Accordion title="NoBytecodeAtAddress" defaultOpen={false}>

    <div>
      <strong>Signature:</strong>
      <ExpandableCode language="solidity" maxLines={5}>
error NoBytecodeAtAddress(address _contractAddress);
      </ExpandableCode>
    </div>
  </Accordion>
</AccordionGroup>

<!-- Usage Example section commented out for now -->
<!--
## Usage Example

<ExpandableCode language="solidity" maxLines={20} title="Example Implementation">
{`pragma solidity >=0.8.30;

import { DiamondMod } from "@compose/diamond/DiamondMod";

contract MyFacet {
    // Assume DiamondMod is deployed and accessible
    // For demonstration, we simulate interaction with its functions.

    function addMyFacet(address _diamondAddress, address _facetAddress) external {
        // In a real deployment, this would be part of the diamond constructor or an initializer.
        // This example shows how the addFacets function might be conceptually used.
        // Note: addFacets is typically called only during initial deployment.
        // This is a conceptual illustration, not a direct callable example from another facet.
        // The actual mechanism involves calling the diamond proxy's upgrade facet.
    }

    function callExternalFunction(bytes4 _selector, address _facetAddress) external {
        // This demonstrates calling a function through the diamond proxy's fallback mechanism.
        // The diamond proxy itself handles the dispatch to the correct facet.
        // This function call would be routed by the diamond proxy if the selector matches a registered function.
        // Example: diamond.diamondFallback(selector, facetAddress, callData);
        // Actual direct call to diamondFallback is not shown here as it's an internal proxy mechanism.
    }

    function getDiamondStorage() internal view returns (DiamondMod.DiamondStorage memory) {
        // This demonstrates accessing the diamond's storage structure.
        // The getStorage function is pure, implying it returns a fixed value related to storage slot identification.
        // To get the actual storage struct, one would typically read from DIAMOND_STORAGE_POSITION.
        // For example: return abi.decode(StorageLib.read(DIAMOND_STORAGE_POSITION), (DiamondMod.DiamondStorage));
        return DiamondMod.getStorage();
    }
}`}
</ExpandableCode>
-->

## Best Practices

<Callout type="tip" title="Best Practice">
- Call `addFacets` only during initial diamond deployment to avoid conflicts.
- Ensure that function selectors are unique across all facets before adding.
- Handle `FunctionNotFound` errors when dispatching calls that do not map to any facet.
</Callout>

## Integration Notes

<Callout type="success" title="Shared Storage">
This module utilizes a dedicated storage position, `DIAMOND_STORAGE_POSITION`, identified by `keccak256("erc8109.diamond")`. The `DiamondStorage` struct, although empty in its definition, serves as a conceptual representation of the state managed at this position. Facets interact with this module's functions to register new facets and their associated function selectors, influencing the diamond's runtime behavior. Any updates to the facet mappings are immediately visible to all facets interacting with the diamond proxy.
</Callout>

<div style={{marginTop: "3rem", paddingTop: "2rem", borderTop: "1px solid var(--ifm-color-emphasis-200)"}}>
  <WasThisHelpful pageId="DiamondMod" />
</div>

<LastUpdated date="2025-12-30T20:14:48.209Z" />
