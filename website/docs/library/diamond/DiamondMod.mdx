---
sidebar_position: 99
title: "DiamondMod"
description: "Internal functions and storage for diamond proxy."
gitSource: "https://github.com/Perfect-Abstractions/Compose/tree/main/src/diamond/DiamondMod.sol"
---

import DocSubtitle  from '@site/src/components/docs/DocSubtitle';
import Badge from '@site/src/components/ui/Badge';
import Callout from '@site/src/components/ui/Callout';
import CalloutBox from '@site/src/components/ui/CalloutBox';
import Accordion, { AccordionGroup } from '@site/src/components/ui/Accordion';
import PropertyTable from '@site/src/components/api/PropertyTable';
import ExpandableCode from '@site/src/components/code/ExpandableCode';
import CodeShowcase from '@site/src/components/code/CodeShowcase';
import RelatedDocs from '@site/src/components/docs/RelatedDocs';
import WasThisHelpful from '@site/src/components/docs/WasThisHelpful';
import LastUpdated from '@site/src/components/docs/LastUpdated';
import ReadingTime from '@site/src/components/docs/ReadingTime';
import GradientText from '@site/src/components/ui/GradientText';
import GradientButton from '@site/src/components/ui/GradientButton';

<DocSubtitle>
Internal functions and storage for diamond proxy.
</DocSubtitle>

<Callout type="info" title="Key Features">
- Manages the addition of facets and their function selectors during diamond deployment.
- Provides a fallback mechanism to route external calls to the correct facet implementation.
- Exposes internal storage access for introspection and debugging.
</Callout>

<Callout type="info" title="Module Usage">
This module provides internal functions for use in your custom facets. Import it to access shared logic and storage.
</Callout>

## Overview

The DiamondMod module provides essential internal logic for managing facets and function routing within a diamond proxy. It handles adding new facets during deployment and delegates calls to the appropriate facet, ensuring core diamond proxy operations are functional and secure.

---

## Storage

### FacetCutAction

Add=0, Replace=1, Remove=2

---
### DiamondStorage

storage-location: erc8042:compose.diamond

<ExpandableCode language="solidity" maxLines={15} title="Definition">
{`struct DiamondStorage {
    mapping(bytes4 functionSelector => FacetAndPosition) facetAndPosition;
    /**
    * \`selectors\` contains all function selectors that can be called in the diamond.
    */
    bytes4[] selectors;
}`}
</ExpandableCode>

---
### FacetAndPosition

<ExpandableCode language="solidity" maxLines={15} title="Definition">
{`struct FacetAndPosition {
    address facet;
    uint32 position;
}`}
</ExpandableCode>

---
### FacetCut

<ExpandableCode language="solidity" maxLines={15} title="Definition">
{`struct FacetCut {
    address facetAddress;
    FacetCutAction action;
    bytes4[] functionSelectors;
}`}
</ExpandableCode>

### State Variables

<PropertyTable
  properties={[
    {
      name: "DIAMOND_STORAGE_POSITION",
      type: "bytes32",
      description: "Diamond storage slot position for this module (Value: `keccak256(\"compose.diamond\")`)"
    }
  ]}
  showRequired={false}
/>

## Functions

### addFacets

Adds facets and their function selectors to the diamond. Only supports adding functions during diamond deployment.

<ExpandableCode language="solidity" maxLines={8}>
{`function addFacets(FacetCut[] memory _facets) ;`}
</ExpandableCode>

**Parameters:**

<PropertyTable
  properties={[
    {
      name: "_facets",
      type: "FacetCut[]",
      description: ""
    }
  ]}
  showRequired={false}
/>

---
### diamondFallback

Find facet for function that is called and execute the function if a facet is found and return any value.

<ExpandableCode language="solidity" maxLines={8}>
{`function diamondFallback() ;`}
</ExpandableCode>

---
### getStorage

<ExpandableCode language="solidity" maxLines={8}>
{`function getStorage() pure returns (DiamondStorage storage s);`}
</ExpandableCode>

## Events

<AccordionGroup>
  <Accordion title="DiamondCut" defaultOpen={false}>

    <div style={{marginBottom: "1rem"}}>
      <strong>Signature:</strong>
      <ExpandableCode language="solidity" maxLines={5}>
{`event DiamondCut(FacetCut[] _diamondCut, address _init, bytes _calldata);`}
      </ExpandableCode>
    </div>

  </Accordion>
</AccordionGroup>

## Errors

<AccordionGroup>
  <Accordion title="CannotAddFunctionToDiamondThatAlreadyExists" defaultOpen={false}>

    <div>
      <strong>Signature:</strong>
      <ExpandableCode language="solidity" maxLines={5}>
error CannotAddFunctionToDiamondThatAlreadyExists(bytes4 _selector);
      </ExpandableCode>
    </div>
  </Accordion>
  <Accordion title="FunctionNotFound" defaultOpen={false}>

    <div>
      <strong>Signature:</strong>
      <ExpandableCode language="solidity" maxLines={5}>
error FunctionNotFound(bytes4 _selector);
      </ExpandableCode>
    </div>
  </Accordion>
  <Accordion title="InvalidActionWhenDeployingDiamond" defaultOpen={false}>

    <div>
      <strong>Signature:</strong>
      <ExpandableCode language="solidity" maxLines={5}>
error InvalidActionWhenDeployingDiamond(address facetAddress, FacetCutAction action, bytes4[] functionSelectors);
      </ExpandableCode>
    </div>
  </Accordion>
  <Accordion title="NoBytecodeAtAddress" defaultOpen={false}>

    <div>
      <strong>Signature:</strong>
      <ExpandableCode language="solidity" maxLines={5}>
error NoBytecodeAtAddress(address _contractAddress, string _message);
      </ExpandableCode>
    </div>
  </Accordion>
</AccordionGroup>

## Usage Example

<ExpandableCode language="solidity" maxLines={20} title="Example Implementation">
{`pragma solidity ^0.8.30;

import {IDiamondMod} from "./interfaces/IDiamondMod.sol";

contract MyFacet {
    IDiamondMod internal diamondMod;

    constructor(address _diamondMod) {
        diamondMod = IDiamondMod(_diamondMod);
    }

    /**
     * @notice Example of calling a function within the diamond proxy.
     */
    function callSomeDiamondFunction() external {
        // Assuming a function \`someFacetFunction\` exists and is routed
        // to a facet managed by DiamondMod
        (bool success, bytes memory data) = address(diamondMod).call(abi.encodeWithSignature(\"someFacetFunction()\"));
        require(success, \"Call to someFacetFunction failed\");
        // Process data if needed
    }
}`}
</ExpandableCode>

## Best Practices

<Callout type="tip" title="Best Practice">
- Facet additions are restricted to the initial diamond deployment phase to maintain proxy integrity.
- Ensure correct function selectors are provided when adding facets to avoid routing issues.
- Handle potential `FunctionNotFound` errors when calling `diamondFallback` directly or indirectly.
</Callout>

## Integration Notes

<Callout type="success" title="Shared Storage">
DiamondMod interacts directly with the diamond proxy's storage to map function selectors to facet addresses. The `addFacets` function must be called during the initial deployment of the diamond. The `diamondFallback` function is crucial for the diamond proxy's operation, as it determines which facet executes an incoming call. Facets can access the DiamondMod contract via its address to perform these core proxy operations.
</Callout>

<div style={{marginTop: "3rem", paddingTop: "2rem", borderTop: "1px solid var(--ifm-color-emphasis-200)"}}>
  <WasThisHelpful pageId="DiamondMod" />
</div>

<LastUpdated date="2025-12-28T04:29:52.838Z" />
