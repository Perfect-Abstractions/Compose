---
sidebar_position: 99
title: "ERC721BurnFacet"
description: "Burn ERC721 tokens within a Compose diamond."
gitSource: "https://github.com/Perfect-Abstractions/Compose/tree/main/src/token/ERC721/ERC721/ERC721BurnFacet.sol"
---

import DocSubtitle  from '@site/src/components/docs/DocSubtitle';
import Badge from '@site/src/components/ui/Badge';
import Callout from '@site/src/components/ui/Callout';
import CalloutBox from '@site/src/components/ui/CalloutBox';
import Accordion, { AccordionGroup } from '@site/src/components/ui/Accordion';
import PropertyTable from '@site/src/components/api/PropertyTable';
import ExpandableCode from '@site/src/components/code/ExpandableCode';
import CodeShowcase from '@site/src/components/code/CodeShowcase';
import RelatedDocs from '@site/src/components/docs/RelatedDocs';
import WasThisHelpful from '@site/src/components/docs/WasThisHelpful';
import LastUpdated from '@site/src/components/docs/LastUpdated';
import ReadingTime from '@site/src/components/docs/ReadingTime';
import GradientText from '@site/src/components/ui/GradientText';
import GradientButton from '@site/src/components/ui/GradientButton';

<DocSubtitle>
Burn ERC721 tokens within a Compose diamond.
</DocSubtitle>

<Callout type="info" title="Key Features">
- Burns ERC721 tokens, effectively destroying them.
- Emits standard `Transfer` events for burned tokens (from owner to address(0)).
- Utilizes inline assembly to access the correct storage slot for ERC721 state.
</Callout>

## Overview

The ERC721BurnFacet provides the functionality to destroy ERC721 tokens. It integrates with the diamond proxy pattern to offer a composable way to manage token lifecycle, specifically the burning of owned tokens. This facet ensures that burned tokens are correctly removed from tracking and associated events are emitted.

---

## Storage

### ERC721Storage

<ExpandableCode language="solidity" maxLines={15} title="Definition">
{`struct ERC721Storage {
    mapping(uint256 tokenId => address owner) ownerOf;
    mapping(address owner => uint256 balance) balanceOf;
    mapping(address owner => mapping(address operator => bool approved)) isApprovedForAll;
    mapping(uint256 tokenId => address approved) approved;
}`}
</ExpandableCode>

### State Variables

<PropertyTable
  properties={[
    {
      name: "STORAGE_POSITION",
      type: "bytes32",
      description: "Diamond storage slot position for this module (Value: `keccak256(\"compose.erc721\")`)"
    }
  ]}
  showRequired={false}
/>

## Functions

### burn

Burns (destroys) a token, removing it from enumeration tracking.

<ExpandableCode language="solidity" maxLines={8}>
{`function burn(uint256 _tokenId) external;`}
</ExpandableCode>

**Parameters:**

<PropertyTable
  properties={[
    {
      name: "_tokenId",
      type: "uint256",
      description: "The ID of the token to burn."
    }
  ]}
  showRequired={false}
/>

## Events

<AccordionGroup>
  <Accordion title="Transfer" defaultOpen={false}>

    <div style={{marginBottom: "1rem"}}>
      <strong>Signature:</strong>
      <ExpandableCode language="solidity" maxLines={5}>
{`event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);`}
      </ExpandableCode>
    </div>

  </Accordion>
  <Accordion title="Approval" defaultOpen={false}>

    <div style={{marginBottom: "1rem"}}>
      <strong>Signature:</strong>
      <ExpandableCode language="solidity" maxLines={5}>
{`event Approval(address indexed _owner, address indexed _to, uint256 indexed _tokenId);`}
      </ExpandableCode>
    </div>

  </Accordion>
  <Accordion title="ApprovalForAll" defaultOpen={false}>

    <div style={{marginBottom: "1rem"}}>
      <strong>Signature:</strong>
      <ExpandableCode language="solidity" maxLines={5}>
{`event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);`}
      </ExpandableCode>
    </div>

  </Accordion>
</AccordionGroup>

## Errors

<AccordionGroup>
  <Accordion title="ERC721NonexistentToken" defaultOpen={false}>

    <div>
      <strong>Signature:</strong>
      <ExpandableCode language="solidity" maxLines={5}>
error ERC721NonexistentToken(uint256 _tokenId);
      </ExpandableCode>
    </div>
  </Accordion>
  <Accordion title="ERC721InsufficientApproval" defaultOpen={false}>

    <div>
      <strong>Signature:</strong>
      <ExpandableCode language="solidity" maxLines={5}>
error ERC721InsufficientApproval(address _operator, uint256 _tokenId);
      </ExpandableCode>
    </div>
  </Accordion>
</AccordionGroup>

## Usage Example

<ExpandableCode language="solidity" maxLines={20} title="Example Implementation">
{`pragma solidity ^0.8.30;

import {IDiamondCut} from "@compose/diamond/contracts/interfaces/IDiamondCut.sol";
import {IERC721BurnFacet} from "./interfaces/IERC721BurnFacet.sol";

contract Deployer {
    address immutable diamondAddress;

    constructor(address _diamondAddress) {
        diamondAddress = _diamondAddress;
    }

    function addBurnFacet(address _burnFacetImplementation) external {
        bytes4[] memory selectors = new bytes4[](2);
        selectors[0] = IERC721BurnFacet.getStorage.selector;
        selectors[1] = IERC721BurnFacet.burn.selector;

        IDiamondCut(diamondAddress).diamondCut([
            IDiamondCut.FacetCut({
                facetAddress: _burnFacetImplementation,
                action: IDiamondCut.FacetCutAction.ADD,
                isUnion: false,
                selectors: selectors
            })
        ], address(0), "");
    }

    function burnToken(uint256 _tokenId) external {
        IERC721BurnFacet(diamondAddress).burn(_tokenId);
    }
}`}
</ExpandableCode>

## Best Practices

<Callout type="tip" title="Best Practice">
- Ensure the `ERC721BurnFacet` is added to the diamond with the correct selectors.
- Call `burn` only for tokens owned by the caller or for which the caller has sufficient approval.
- Understand the storage layout by calling `getStorage` if direct interaction with underlying ERC721 state is required.
</Callout>

## Security Considerations

<Callout type="warning" title="Security">
The `burn` function requires the caller to be the owner of the token or have explicit approval. Ensure that the diamond's access control mechanisms correctly enforce these ownership and approval checks before allowing the `burn` function to be executed. Reentrancy is not a concern as `burn` does not make external calls before state changes.
</Callout>

<div style={{marginTop: "3rem", paddingTop: "2rem", borderTop: "1px solid var(--ifm-color-emphasis-200)"}}>
  <WasThisHelpful pageId="ERC721BurnFacet" />
</div>

<LastUpdated date="2025-12-23T00:27:41.008Z" />
