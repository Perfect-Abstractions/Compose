---
sidebar_position: 99
title: "ERC721EnumerableBurnFacet"
description: "Manage ERC721 token burning and enumeration"
gitSource: "https://github.com/Perfect-Abstractions/Compose/tree/main/src/token/ERC721/ERC721Enumerable/ERC721EnumerableBurnFacet.sol"
---

import DocSubtitle  from '@site/src/components/docs/DocSubtitle';
import Badge from '@site/src/components/ui/Badge';
import Callout from '@site/src/components/ui/Callout';
import CalloutBox from '@site/src/components/ui/CalloutBox';
import Accordion, { AccordionGroup } from '@site/src/components/ui/Accordion';
import PropertyTable from '@site/src/components/api/PropertyTable';
import ExpandableCode from '@site/src/components/code/ExpandableCode';
import CodeShowcase from '@site/src/components/code/CodeShowcase';
import RelatedDocs from '@site/src/components/docs/RelatedDocs';
import WasThisHelpful from '@site/src/components/docs/WasThisHelpful';
import LastUpdated from '@site/src/components/docs/LastUpdated';
import ReadingTime from '@site/src/components/docs/ReadingTime';
import GradientText from '@site/src/components/ui/GradientText';
import GradientButton from '@site/src/components/ui/GradientButton';

<DocSubtitle>
Manage ERC721 token burning and enumeration
</DocSubtitle>

<Callout type="info" title="Key Features">
- Enables burning of ERC721 tokens.
- Maintains enumeration integrity by removing burned tokens from tracking.
- Provides explicit error handling for non-existent tokens and insufficient approvals.
</Callout>

## Overview

This facet provides functionality to burn ERC721 tokens. It integrates with the ERC721 enumerable standard, ensuring that burned tokens are correctly removed from tracking and ownership records. This facet is essential for managing the lifecycle of tokens within a Compose diamond.

---

## Storage

### ERC721EnumerableStorage

<ExpandableCode language="solidity" maxLines={15} title="Definition">
{`struct ERC721EnumerableStorage {
    mapping(uint256 tokenId => address owner) ownerOf;
    mapping(address owner => uint256[] ownerTokens) ownerTokens;
    mapping(uint256 tokenId => uint256 ownerTokensIndex) ownerTokensIndex;
    uint256[] allTokens;
    mapping(uint256 tokenId => uint256 allTokensIndex) allTokensIndex;
    mapping(address owner => mapping(address operator => bool approved)) isApprovedForAll;
    mapping(uint256 tokenId => address approved) approved;
}`}
</ExpandableCode>

### State Variables

<PropertyTable
  properties={[
    {
      name: "STORAGE_POSITION",
      type: "bytes32",
      description: "Diamond storage slot position for this module (Value: `keccak256(\"compose.erc721.enumerable\")`)"
    }
  ]}
  showRequired={false}
/>

## Functions

### burn

Burns (destroys) a token, removing it from enumeration tracking.

<ExpandableCode language="solidity" maxLines={8}>
{`function burn(uint256 _tokenId) external;`}
</ExpandableCode>

**Parameters:**

<PropertyTable
  properties={[
    {
      name: "_tokenId",
      type: "uint256",
      description: "The ID of the token to burn."
    }
  ]}
  showRequired={false}
/>

## Events

<AccordionGroup>
  <Accordion title="Transfer" defaultOpen={false}>
    <div style={{marginBottom: "1rem"}}>
      Emitted when ownership of a token changes, including burning.
    </div>

    <div style={{marginBottom: "1rem"}}>
      <strong>Signature:</strong>
      <ExpandableCode language="solidity" maxLines={5}>
{`event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);`}
      </ExpandableCode>
    </div>

    <div style={{marginBottom: "1rem"}}>
      <strong>Parameters:</strong>
      <PropertyTable
        properties={[
          {
            name: "_from",
            type: "address",
            description: "The address transferring the token (or owner when burning)."
          },
          {
            name: "_to",
            type: "address",
            description: "The address receiving the token (zero address when burning)."
          },
          {
            name: "_tokenId",
            type: "uint256",
            description: "The ID of the token being transferred."
          }
        ]}
        showRequired={false}
      />
    </div>
  </Accordion>
</AccordionGroup>

## Errors

<AccordionGroup>
  <Accordion title="ERC721NonexistentToken" defaultOpen={false}>
    <div style={{marginBottom: "1rem"}}>
      Thrown when attempting to interact with a non-existent token.
    </div>

    <div>
      <strong>Signature:</strong>
      <ExpandableCode language="solidity" maxLines={5}>
error ERC721NonexistentToken(uint256 _tokenId);
      </ExpandableCode>
    </div>
  </Accordion>
  <Accordion title="ERC721InsufficientApproval" defaultOpen={false}>
    <div style={{marginBottom: "1rem"}}>
      Thrown when the caller lacks approval to operate on the token.
    </div>

    <div>
      <strong>Signature:</strong>
      <ExpandableCode language="solidity" maxLines={5}>
error ERC721InsufficientApproval(address _operator, uint256 _tokenId);
      </ExpandableCode>
    </div>
  </Accordion>
</AccordionGroup>

## Usage Example

<ExpandableCode language="solidity" maxLines={20} title="Example Implementation">
{`pragma solidity ^0.8.30;

import {IERC721EnumerableBurnFacet} from "@compose-protocol/diamond-contracts/contracts/facets/ERC721/IERC721EnumerableBurnFacet.sol";

contract Usage {
    IERC721EnumerableBurnFacet public immutable erc721EnumerableBurnFacet;

    constructor(address diamondAddress) {
        // Assume diamondAddress is the address of the deployed Compose diamond
        erc721EnumerableBurnFacet = IERC721EnumerableBurnFacet(diamondAddress);
    }

    function burnToken(uint256 tokenId) public {
        // Ensure the caller has the necessary approvals or ownership
        // For simplicity, this example assumes the caller is authorized
        erc721EnumerableBurnFacet.burn(tokenId);
    }
}`}
</ExpandableCode>

## Best Practices

<Callout type="tip" title="Best Practice">
- Ensure the `burn` function is called with appropriate access control (e.g., token owner or approved address).
- Integrate this facet into a diamond that already implements the core ERC721 and ERC721Enumerable interfaces.
- Understand that burning a token is an irreversible action.
</Callout>

## Security Considerations

<Callout type="warning" title="Security">
The `burn` function requires careful access control to prevent unauthorized token destruction. Ensure that only the token owner or an address with explicit approval can call this function. The `ERC721NonexistentToken` and `ERC721InsufficientApproval` errors provide clear feedback on invalid burn attempts.
</Callout>

<div style={{marginTop: "3rem", paddingTop: "2rem", borderTop: "1px solid var(--ifm-color-emphasis-200)"}}>
  <WasThisHelpful pageId="ERC721EnumerableBurnFacet" />
</div>

<LastUpdated date="2025-12-23T00:27:32.776Z" />
