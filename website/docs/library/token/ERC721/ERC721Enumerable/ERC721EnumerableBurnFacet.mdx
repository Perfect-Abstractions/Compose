---
sidebar_position: 99
title: "ERC721EnumerableBurnFacet"
description: "Burn ERC721 tokens and manage enumeration state"
gitSource: "https://github.com/maxnorm/Compose/blob/fc8e8677d3c3fe32a459f173c58ec546dfcb9e13/src/token/ERC721/ERC721Enumerable/ERC721EnumerableBurnFacet.sol"
---

import DocSubtitle  from '@site/src/components/docs/DocSubtitle';
import Badge from '@site/src/components/ui/Badge';
import Callout from '@site/src/components/ui/Callout';
import CalloutBox from '@site/src/components/ui/CalloutBox';
import Accordion, { AccordionGroup } from '@site/src/components/ui/Accordion';
import PropertyTable from '@site/src/components/api/PropertyTable';
import ExpandableCode from '@site/src/components/code/ExpandableCode';
import CodeShowcase from '@site/src/components/code/CodeShowcase';
import RelatedDocs from '@site/src/components/docs/RelatedDocs';
import WasThisHelpful from '@site/src/components/docs/WasThisHelpful';
import LastUpdated from '@site/src/components/docs/LastUpdated';
import ReadingTime from '@site/src/components/docs/ReadingTime';
import GradientText from '@site/src/components/ui/GradientText';
import GradientButton from '@site/src/components/ui/GradientButton';

<DocSubtitle>
Burn ERC721 tokens and manage enumeration state
</DocSubtitle>

<Callout type="info" title="Key Features">
- Enables the burning of ERC721 tokens.
- Automatically updates internal enumeration tracking upon token burn.
- Emits a `Transfer` event for burned tokens, signifying their removal from circulation.
</Callout>

## Overview

This facet provides functionality to burn ERC721 tokens. It integrates with the enumeration tracking mechanisms to ensure that burned tokens are correctly removed from the tracked list, maintaining the integrity of the token supply.

---

## Storage

### ERC721EnumerableStorage

<ExpandableCode language="solidity" maxLines={15} title="Definition">
{`struct ERC721EnumerableStorage {
    mapping(uint256 tokenId => address owner) ownerOf;
    mapping(address owner => uint256[] ownerTokens) ownerTokens;
    mapping(uint256 tokenId => uint256 ownerTokensIndex) ownerTokensIndex;
    uint256[] allTokens;
    mapping(uint256 tokenId => uint256 allTokensIndex) allTokensIndex;
    mapping(address owner => mapping(address operator => bool approved)) isApprovedForAll;
    mapping(uint256 tokenId => address approved) approved;
}`}
</ExpandableCode>

### State Variables

<PropertyTable
  properties={[
    {
      name: "STORAGE_POSITION",
      type: "constant",
      description: "Diamond storage slot position for this module"
    }
  ]}
  showRequired={false}
/>

## Functions

### getStorage

Returns the storage struct used by this facet.

<ExpandableCode language="solidity" maxLines={8}>
{`function getStorage() internal pure returns (ERC721EnumerableStorage storage s);`}
</ExpandableCode>

**Returns:**

<PropertyTable
  properties={[
    {
      name: "s",
      type: "ERC721EnumerableStorage",
      description: "The ERC721Enumerable storage struct."
    }
  ]}
  showRequired={false}
/>

---
### burn

Burns (destroys) a token, removing it from enumeration tracking.

<ExpandableCode language="solidity" maxLines={8}>
{`function burn(uint256 _tokenId) external;`}
</ExpandableCode>

**Parameters:**

<PropertyTable
  properties={[
    {
      name: "_tokenId",
      type: "uint256",
      description: "The ID of the token to burn."
    }
  ]}
  showRequired={false}
/>

## Events

<AccordionGroup>
  <Accordion title="Transfer" defaultOpen={false}>
    <div style={{marginBottom: "1rem"}}>
      Emitted when ownership of a token changes, including burning.
    </div>

    <div style={{marginBottom: "1rem"}}>
      <strong>Signature:</strong>
      <ExpandableCode language="solidity" maxLines={5}>
{`event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);`}
      </ExpandableCode>
    </div>

    <div style={{marginBottom: "1rem"}}>
      <strong>Parameters:</strong>
      <PropertyTable
        properties={[
          {
            name: "_from",
            type: "address",
            description: "The address transferring the token (or owner when burning)."
          },
          {
            name: "_to",
            type: "address",
            description: "The address receiving the token (zero address when burning)."
          },
          {
            name: "_tokenId",
            type: "uint256",
            description: "The ID of the token being transferred."
          }
        ]}
        showRequired={false}
      />
    </div>
  </Accordion>
</AccordionGroup>

## Errors

<AccordionGroup>
  <Accordion title="ERC721NonexistentToken" defaultOpen={false}>
    <div style={{marginBottom: "1rem"}}>
      Thrown when attempting to interact with a non-existent token.
    </div>

    <div>
      <strong>Signature:</strong>
      <ExpandableCode language="solidity" maxLines={5}>
error ERC721NonexistentToken(uint256 _tokenId);
      </ExpandableCode>
    </div>
  </Accordion>
  <Accordion title="ERC721InsufficientApproval" defaultOpen={false}>
    <div style={{marginBottom: "1rem"}}>
      Thrown when the caller lacks approval to operate on the token.
    </div>

    <div>
      <strong>Signature:</strong>
      <ExpandableCode language="solidity" maxLines={5}>
error ERC721InsufficientApproval(address _operator, uint256 _tokenId);
      </ExpandableCode>
    </div>
  </Accordion>
</AccordionGroup>

## Usage Example

<ExpandableCode language="solidity" maxLines={20} title="Example Implementation">
{`pragma solidity ^0.8.30;

import {IERC721EnumerableBurn } from "@compose-protocol/core/contracts/facets/ERC721/IERC721EnumerableBurn.sol";

contract ExampleConsumer {
    IERC721EnumerableBurn private constant ERC721_ENUMERABLE_BURN_FACET = IERC721EnumerableBurn(0x...); // Diamond proxy address

    function burnToken(uint256 tokenId) external {
        // Assume appropriate approvals and ownership checks are handled by access control or other facets
        ERC721_ENUMERABLE_BURN_FACET.burn(tokenId);
    }
}`}
</ExpandableCode>

## Best Practices

<Callout type="tip" title="Best Practice">
- Ensure proper access control is implemented before calling the `burn` function to prevent unauthorized token destruction.
- Integrate with other ERC721 facets (like `ERC721Receiver`) to handle post-burn logic if necessary.
</Callout>

## Security Considerations

<Callout type="warning" title="Security">
The `burn` function requires careful access control to prevent unauthorized burning of tokens. Ensure that only the token owner or an authorized operator can call this function. The `ERC721NonexistentToken` error is raised if the token ID does not exist, and `ERC721InsufficientApproval` is raised if the caller does not have sufficient approval to burn the token.
</Callout>

<div style={{marginTop: "3rem", paddingTop: "2rem", borderTop: "1px solid var(--ifm-color-emphasis-200)"}}>
  <WasThisHelpful pageId="ERC721EnumerableBurnFacet" />
</div>

<LastUpdated date="2025-12-21T21:25:56.925Z" />
