---
sidebar_position: 99
title: "ERC721EnumerableBurnFacet"
description: "Burn ERC721 tokens and manage enumeration state."
gitSource: "https://github.com/maxnorm/Compose/blob/ff6fa8311504bcc485d7920faddca96c4144627c/src/token/ERC721/ERC721Enumerable/ERC721EnumerableBurnFacet.sol"
---

import DocSubtitle  from '@site/src/components/docs/DocSubtitle';
import Badge from '@site/src/components/ui/Badge';
import Callout from '@site/src/components/ui/Callout';
import CalloutBox from '@site/src/components/ui/CalloutBox';
import Accordion, { AccordionGroup } from '@site/src/components/ui/Accordion';
import PropertyTable from '@site/src/components/api/PropertyTable';
import ExpandableCode from '@site/src/components/code/ExpandableCode';
import CodeShowcase from '@site/src/components/code/CodeShowcase';
import RelatedDocs from '@site/src/components/docs/RelatedDocs';
import WasThisHelpful from '@site/src/components/docs/WasThisHelpful';
import LastUpdated from '@site/src/components/docs/LastUpdated';
import ReadingTime from '@site/src/components/docs/ReadingTime';
import GradientText from '@site/src/components/ui/GradientText';
import GradientButton from '@site/src/components/ui/GradientButton';

<DocSubtitle>
Burn ERC721 tokens and manage enumeration state.
</DocSubtitle>

<Callout type="info" title="Key Features">
- Allows burning of ERC721 tokens.
- Integrates with enumeration logic to remove burned tokens from tracking.
- Emits a `Transfer` event with `from` and `to` addresses set to the zero address for burned tokens.
</Callout>

## Overview

The ERC721EnumerableBurnFacet provides functionality to burn ERC721 tokens within a Compose diamond. It ensures that burned tokens are correctly removed from enumeration tracking, maintaining the integrity of the token supply and ownership data.

---

## Storage

### ERC721EnumerableStorage

<ExpandableCode language="solidity" maxLines={15} title="Definition">
{`struct ERC721EnumerableStorage {
    mapping(uint256 tokenId => address owner) ownerOf;
    mapping(address owner => uint256[] ownerTokens) ownerTokens;
    mapping(uint256 tokenId => uint256 ownerTokensIndex) ownerTokensIndex;
    uint256[] allTokens;
    mapping(uint256 tokenId => uint256 allTokensIndex) allTokensIndex;
    mapping(address owner => mapping(address operator => bool approved)) isApprovedForAll;
    mapping(uint256 tokenId => address approved) approved;
}`}
</ExpandableCode>

### State Variables

<PropertyTable
  properties={[
    {
      name: "STORAGE_POSITION",
      type: "constant",
      description: "Diamond storage slot position for this module"
    }
  ]}
  showRequired={false}
/>

## Functions

### getStorage

Returns the storage struct used by this facet.

<ExpandableCode language="solidity" maxLines={8}>
{`function getStorage() internal pure returns (ERC721EnumerableStorage storage s);`}
</ExpandableCode>

**Returns:**

<PropertyTable
  properties={[
    {
      name: "s",
      type: "ERC721EnumerableStorage",
      description: "The ERC721Enumerable storage struct."
    }
  ]}
  showRequired={false}
/>

---
### burn

Burns (destroys) a token, removing it from enumeration tracking.

<ExpandableCode language="solidity" maxLines={8}>
{`function burn(uint256 _tokenId) external;`}
</ExpandableCode>

**Parameters:**

<PropertyTable
  properties={[
    {
      name: "_tokenId",
      type: "uint256",
      description: "The ID of the token to burn."
    }
  ]}
  showRequired={false}
/>

## Events

<AccordionGroup>
  <Accordion title="Transfer" defaultOpen={false}>
    <div style={{marginBottom: "1rem"}}>
      Emitted when ownership of a token changes, including burning.
    </div>

    <div style={{marginBottom: "1rem"}}>
      <strong>Signature:</strong>
      <ExpandableCode language="solidity" maxLines={5}>
{`event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);`}
      </ExpandableCode>
    </div>

    <div style={{marginBottom: "1rem"}}>
      <strong>Parameters:</strong>
      <PropertyTable
        properties={[
          {
            name: "_from",
            type: "address",
            description: "The address transferring the token (or owner when burning)."
          },
          {
            name: "_to",
            type: "address",
            description: "The address receiving the token (zero address when burning)."
          },
          {
            name: "_tokenId",
            type: "uint256",
            description: "The ID of the token being transferred."
          }
        ]}
        showRequired={false}
      />
    </div>
  </Accordion>
</AccordionGroup>

## Errors

<AccordionGroup>
  <Accordion title="ERC721NonexistentToken" defaultOpen={false}>
    <div style={{marginBottom: "1rem"}}>
      Thrown when attempting to interact with a non-existent token.
    </div>

    <div>
      <strong>Signature:</strong>
      <ExpandableCode language="solidity" maxLines={5}>
error ERC721NonexistentToken(uint256 _tokenId);
      </ExpandableCode>
    </div>
  </Accordion>
  <Accordion title="ERC721InsufficientApproval" defaultOpen={false}>
    <div style={{marginBottom: "1rem"}}>
      Thrown when the caller lacks approval to operate on the token.
    </div>

    <div>
      <strong>Signature:</strong>
      <ExpandableCode language="solidity" maxLines={5}>
error ERC721InsufficientApproval(address _operator, uint256 _tokenId);
      </ExpandableCode>
    </div>
  </Accordion>
</AccordionGroup>

## Usage Example

<ExpandableCode language="solidity" maxLines={20} title="Example Implementation">
{`pragma solidity ^0.8.30;

import {IERC721EnumerableBurnFacet} from "@compose/contracts/facets/ERC721/IERC721EnumerableBurnFacet.sol";

contract BurnExample {
    address immutable diamondAddress;

    constructor(address _diamondAddress) {
        diamondAddress = _diamondAddress;
    }

    function burnToken(uint256 _tokenId) external {
        IERC721EnumerableBurnFacet(diamondAddress).burn(_tokenId);
    }

    // Example of getting storage (for inspection or advanced logic)
    function getFacetStorage() external view returns (bytes memory) {
        return IERC721EnumerableBurnFacet(diamondAddress).getStorage();
    }
}`}
</ExpandableCode>

## Best Practices

<Callout type="tip" title="Best Practice">
- Ensure proper access control is implemented at the diamond level before calling the `burn` function to prevent unauthorized token destruction.
- Verify that the token ID provided to `burn` actually exists to avoid `ERC721NonexistentToken` errors.
- Understand that burning a token is irreversible and removes it from all enumeration.
</Callout>

## Security Considerations

<Callout type="warning" title="Security">
The `burn` function requires that the caller either be the owner of the token or have been granted sufficient approval. Failure to meet these conditions will result in an `ERC721InsufficientApproval` error. Additionally, calling `burn` on a non-existent token will revert with `ERC721NonexistentToken`. Ensure that the diamond's access control layer correctly restricts who can call these functions.
</Callout>

<div style={{marginTop: "3rem", paddingTop: "2rem", borderTop: "1px solid var(--ifm-color-emphasis-200)"}}>
  <WasThisHelpful pageId="ERC721EnumerableBurnFacet" />
</div>

<LastUpdated date="2025-12-21T20:14:14.451Z" />
