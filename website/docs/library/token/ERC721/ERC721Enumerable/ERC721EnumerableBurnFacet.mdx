---
sidebar_position: 99
title: "ERC721EnumerableBurnFacet"
description: "Enables burning of ERC721 tokens and maintains enumeration."
gitSource: "https://github.com/Perfect-Abstractions/Compose/tree/main/src/token/ERC721/ERC721Enumerable/ERC721EnumerableBurnFacet.sol"
---

import DocSubtitle  from '@site/src/components/docs/DocSubtitle';
import Badge from '@site/src/components/ui/Badge';
import Callout from '@site/src/components/ui/Callout';
import CalloutBox from '@site/src/components/ui/CalloutBox';
import Accordion, { AccordionGroup } from '@site/src/components/ui/Accordion';
import PropertyTable from '@site/src/components/api/PropertyTable';
import ExpandableCode from '@site/src/components/code/ExpandableCode';
import CodeShowcase from '@site/src/components/code/CodeShowcase';
import RelatedDocs from '@site/src/components/docs/RelatedDocs';
import WasThisHelpful from '@site/src/components/docs/WasThisHelpful';
import LastUpdated from '@site/src/components/docs/LastUpdated';
import ReadingTime from '@site/src/components/docs/ReadingTime';
import GradientText from '@site/src/components/ui/GradientText';
import GradientButton from '@site/src/components/ui/GradientButton';

<DocSubtitle>
Enables burning of ERC721 tokens and maintains enumeration.
</DocSubtitle>

<Callout type="info" title="Key Features">
- Supports the burning of ERC721 tokens, removing them from circulation.
- Maintains the integrity of token enumeration after a burn operation, ensuring `totalSupply` and token indices remain accurate.
</Callout>

## Overview

The ERC721EnumerableBurnFacet provides functionality to burn ERC721 tokens. It integrates with the diamond proxy pattern to manage token destruction while ensuring that the enumeration of remaining tokens is correctly updated.

---

## Storage

### ERC721EnumerableStorage

<ExpandableCode language="solidity" maxLines={15} title="Definition">
{`struct ERC721EnumerableStorage {
    mapping(uint256 tokenId => address owner) ownerOf;
    mapping(address owner => uint256[] ownerTokens) ownerTokens;
    mapping(uint256 tokenId => uint256 ownerTokensIndex) ownerTokensIndex;
    uint256[] allTokens;
    mapping(uint256 tokenId => uint256 allTokensIndex) allTokensIndex;
    mapping(address owner => mapping(address operator => bool approved)) isApprovedForAll;
    mapping(uint256 tokenId => address approved) approved;
}`}
</ExpandableCode>

### State Variables

<PropertyTable
  properties={[
    {
      name: "STORAGE_POSITION",
      type: "constant",
      description: "Diamond storage slot position for this module"
    }
  ]}
  showRequired={false}
/>

## Functions

### burn

Burns (destroys) a token, removing it from enumeration tracking.

<ExpandableCode language="solidity" maxLines={8}>
{`function burn(uint256 _tokenId) external;`}
</ExpandableCode>

**Parameters:**

<PropertyTable
  properties={[
    {
      name: "_tokenId",
      type: "uint256",
      description: "The ID of the token to burn."
    }
  ]}
  showRequired={false}
/>

## Events

<AccordionGroup>
  <Accordion title="Transfer" defaultOpen={false}>
    <div style={{marginBottom: "1rem"}}>
      Emitted when ownership of a token changes, including burning.
    </div>

    <div style={{marginBottom: "1rem"}}>
      <strong>Signature:</strong>
      <ExpandableCode language="solidity" maxLines={5}>
{`event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);`}
      </ExpandableCode>
    </div>

    <div style={{marginBottom: "1rem"}}>
      <strong>Parameters:</strong>
      <PropertyTable
        properties={[
          {
            name: "_from",
            type: "address",
            description: "The address transferring the token (or owner when burning)."
          },
          {
            name: "_to",
            type: "address",
            description: "The address receiving the token (zero address when burning)."
          },
          {
            name: "_tokenId",
            type: "uint256",
            description: "The ID of the token being transferred."
          }
        ]}
        showRequired={false}
      />
    </div>
  </Accordion>
</AccordionGroup>

## Errors

<AccordionGroup>
  <Accordion title="ERC721NonexistentToken" defaultOpen={false}>
    <div style={{marginBottom: "1rem"}}>
      Thrown when attempting to interact with a non-existent token.
    </div>

    <div>
      <strong>Signature:</strong>
      <ExpandableCode language="solidity" maxLines={5}>
error ERC721NonexistentToken(uint256 _tokenId);
      </ExpandableCode>
    </div>
  </Accordion>
  <Accordion title="ERC721InsufficientApproval" defaultOpen={false}>
    <div style={{marginBottom: "1rem"}}>
      Thrown when the caller lacks approval to operate on the token.
    </div>

    <div>
      <strong>Signature:</strong>
      <ExpandableCode language="solidity" maxLines={5}>
error ERC721InsufficientApproval(address _operator, uint256 _tokenId);
      </ExpandableCode>
    </div>
  </Accordion>
</AccordionGroup>

## Usage Example

<ExpandableCode language="solidity" maxLines={20} title="Example Implementation">
{`pragma solidity ^0.8.30;

import {IERC721EnumerableBurnFacet} from "@compose/contracts/facets/ERC721/IERC721EnumerableBurnFacet.sol";

contract MyDiamond {
    // Assume diamond deployment and initialization have occurred.
    // The ERC721EnumerableBurnFacet has been added and selectors are registered.

    // Example of calling the burn function
    function burnToken(address _to, uint256 _tokenId) external {
        // Get the facet instance
        IERC721EnumerableBurnFacet burnFacet = IERC721EnumerableBurnFacet(address(this));

        // Call the burn function
        // Note: Access control for who can burn should be implemented externally or via a separate facet.
        burnFacet.burn(_to, _tokenId);
    }

    // Example of getting storage (for diagnostic purposes or advanced logic)
    function getBurnFacetStorage() external view returns (IERC721EnumerableBurnFacet.ERC721EnumerableBurnStorage memory) {
        IERC721EnumerableBurnFacet burnFacet = IERC721EnumerableBurnFacet(address(this));
        return burnFacet.getStorage();
    }
}`}
</ExpandableCode>

## Best Practices

<Callout type="tip" title="Best Practice">
- Ensure proper access control is implemented in a separate facet or contract before allowing calls to the `burn` function to prevent unauthorized token destruction.
- Integrate this facet into your diamond's upgrade process, ensuring the `Transfer` event is handled correctly by your diamond's event aggregator if applicable.
</Callout>

## Security Considerations

<Callout type="warning" title="Security">
The `burn` function should be protected by robust access control mechanisms to prevent unauthorized token destruction. Ensure that the `_to` address passed to `burn` is the current owner of the token being burned, and that the caller has the necessary approval or ownership rights. The `ERC721NonexistentToken` and `ERC721InsufficientApproval` errors provide basic validation.
</Callout>

<div style={{marginTop: "3rem", paddingTop: "2rem", borderTop: "1px solid var(--ifm-color-emphasis-200)"}}>
  <WasThisHelpful pageId="ERC721EnumerableBurnFacet" />
</div>

<LastUpdated date="2025-12-23T00:01:35.453Z" />
