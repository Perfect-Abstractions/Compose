---
sidebar_position: 1
title: "ERC20PermitMod"
description: "ERC-2612 permit logic and domain separator"
gitSource: "https://github.com/Perfect-Abstractions/Compose/tree/main/src/token/ERC20/ERC20Permit/ERC20PermitMod.sol"
---

import DocSubtitle  from '@site/src/components/docs/DocSubtitle';
import Badge from '@site/src/components/ui/Badge';
import Callout from '@site/src/components/ui/Callout';
import CalloutBox from '@site/src/components/ui/CalloutBox';
import Accordion, { AccordionGroup } from '@site/src/components/ui/Accordion';
import PropertyTable from '@site/src/components/api/PropertyTable';
import ExpandableCode from '@site/src/components/code/ExpandableCode';
import CodeShowcase from '@site/src/components/code/CodeShowcase';
import RelatedDocs from '@site/src/components/docs/RelatedDocs';
import WasThisHelpful from '@site/src/components/docs/WasThisHelpful';
import LastUpdated from '@site/src/components/docs/LastUpdated';
import ReadingTime from '@site/src/components/docs/ReadingTime';
import GradientText from '@site/src/components/ui/GradientText';
import GradientButton from '@site/src/components/ui/GradientButton';

<DocSubtitle>
ERC-2612 permit logic and domain separator
</DocSubtitle>

<Callout type="info" title="Key Features">
- Provides ERC-2612 permit logic for signed token approvals.
- Exposes `DOMAIN_SEPARATOR` for signature encoding.
- Uses diamond storage pattern for persistent state management.
- Functions are `pure` or `view` where applicable, facilitating static analysis.
</Callout>

<Callout type="info" title="Module Usage">
This module provides internal functions for use in your custom facets. Import it to access shared logic and storage.
</Callout>

## Overview

This module provides ERC-2612 permit functionality, enabling off-chain approvals via signed messages. Facets can integrate this module to manage signed token approvals, leveraging shared diamond storage for consistency. The domain separator ensures signature validity across different contract deployments.

---

## Storage

### ERC20PermitStorage

storage-location: erc8042:compose.erc20.permit

<ExpandableCode language="solidity" maxLines={15} title="Definition">
{`struct ERC20PermitStorage {
    mapping(address owner => uint256) nonces;
}`}
</ExpandableCode>

---
### ERC20Storage

storage-location: erc8042:compose.erc20

<ExpandableCode language="solidity" maxLines={15} title="Definition">
{`struct ERC20Storage {
    mapping(address owner => uint256 balance) balanceOf;
    uint256 totalSupply;
    mapping(address owner => mapping(address spender => uint256 allowance)) allowance;
    uint8 decimals;
    string name;
}`}
</ExpandableCode>

### State Variables

<PropertyTable
  properties={[
    {
      name: "ERC20_STORAGE_POSITION",
      type: "bytes32",
      description: "Diamond storage slot position for this module (Value: `keccak256(\"compose.erc20\")`)"
    },
    {
      name: "STORAGE_POSITION",
      type: "bytes32",
      description: "Diamond storage slot position for this module (Value: `keccak256(\"compose.erc20.permit\")`)"
    }
  ]}
  showRequired={false}
/>

## Functions

### DOMAIN_SEPARATOR

Returns the domain separator used in the encoding of the signature for &#123;permit&#125;. This value is unique to a contract and chain ID combination to prevent replay attacks.

<ExpandableCode language="solidity" maxLines={8}>
{`function DOMAIN_SEPARATOR() view returns (bytes32);`}
</ExpandableCode>

**Returns:**

<PropertyTable
  properties={[
    {
      name: "-",
      type: "bytes32",
      description: "The domain separator."
    }
  ]}
  showRequired={false}
/>

---
### getERC20Storage

<ExpandableCode language="solidity" maxLines={8}>
{`function getERC20Storage() pure returns (ERC20Storage storage s);`}
</ExpandableCode>

---
### getPermitStorage

<ExpandableCode language="solidity" maxLines={8}>
{`function getPermitStorage() pure returns (ERC20PermitStorage storage s);`}
</ExpandableCode>

---
### permit

Validates a permit signature and sets allowance. Emits Approval event; must be emitted by the calling facet/contract.

<ExpandableCode language="solidity" maxLines={8}>
{`function permit(address _owner, address _spender, uint256 _value, uint256 _deadline, uint8 _v, bytes32 _r, bytes32 _s) ;`}
</ExpandableCode>

**Parameters:**

<PropertyTable
  properties={[
    {
      name: "_owner",
      type: "address",
      description: "Token owner."
    },
    {
      name: "_spender",
      type: "address",
      description: "Token spender."
    },
    {
      name: "_value",
      type: "uint256",
      description: "Allowance value."
    },
    {
      name: "_deadline",
      type: "uint256",
      description: "Permit\'s time deadline."
    }
  ]}
  showRequired={false}
/>

## Events

<AccordionGroup>
  <Accordion title="Approval" defaultOpen={false}>
    <div style={{marginBottom: "1rem"}}>
      Emitted when an approval is made for a spender by an owner.
    </div>

    <div style={{marginBottom: "1rem"}}>
      <strong>Signature:</strong>
      <ExpandableCode language="solidity" maxLines={5}>
{`event Approval(address indexed _owner, address indexed _spender, uint256 _value);`}
      </ExpandableCode>
    </div>

    <div style={{marginBottom: "1rem"}}>
      <strong>Parameters:</strong>
      <PropertyTable
        properties={[
          {
            name: "_owner",
            type: "address",
            description: "The address granting the allowance."
          },
          {
            name: "_spender",
            type: "address",
            description: "The address receiving the allowance."
          },
          {
            name: "_value",
            type: "uint256",
            description: "The amount approved."
          }
        ]}
        showRequired={false}
      />
    </div>
  </Accordion>
</AccordionGroup>

## Errors

<AccordionGroup>
  <Accordion title="ERC20InvalidSpender" defaultOpen={false}>
    <div style={{marginBottom: "1rem"}}>
      Thrown when the spender address is invalid (e.g., zero address).
    </div>

    <div>
      <strong>Signature:</strong>
      <ExpandableCode language="solidity" maxLines={5}>
error ERC20InvalidSpender(address _spender);
      </ExpandableCode>
    </div>
  </Accordion>
  <Accordion title="ERC2612InvalidSignature" defaultOpen={false}>
    <div style={{marginBottom: "1rem"}}>
      Thrown when a permit signature is invalid or expired.
    </div>

    <div>
      <strong>Signature:</strong>
      <ExpandableCode language="solidity" maxLines={5}>
error ERC2612InvalidSignature(
address _owner, address _spender, uint256 _value, uint256 _deadline, uint8 _v, bytes32 _r, bytes32 _s
);
      </ExpandableCode>
    </div>
  </Accordion>
</AccordionGroup>

<!-- Usage Example section commented out for now -->
<!--
## Usage Example

<ExpandableCode language="solidity" maxLines={20} title="Example Implementation">
{`pragma solidity >=0.8.30;
import { ERC20PermitMod } from "@compose/token/ERC20/ERC20Permit/ERC20PermitMod";

contract MyERC20Facet {
    // Assume ERC20PermitMod is correctly initialized and its storage is accessible via diamond storage.
    // Assume necessary access control and error handling are in place.

    function executePermit(
        address _owner,
        address _spender,
        uint256 _value,
        uint256 _deadline,
        uint8 _v,
        bytes32 _r,
        bytes32 _s
    ) external {
        // This is a conceptual example. In a real scenario, you would call a private or internal function
        // within this facet that then calls ERC20PermitMod.permit.
        // The actual permit function in the module validates the signature and sets the allowance.
        // The Approval event must be emitted by the calling facet.

        // For demonstration, let's assume a direct call pattern for clarity, though typically an internal helper would be used.
        // The actual ERC20PermitMod.permit function does not emit the event; the caller must.

        // ERC20PermitMod.permit(_owner, _spender, _value, _deadline, _v, _r, _s);
        // emit Approval(_owner, _spender, _value);

        // Note: The actual implementation would involve retrieving storage and calling the internal logic.
        // The provided contract data does not expose an internal permit function for direct facet use in this manner.
        // The 'permit' function signature suggests it's meant to be called directly within the module context.
        // For a facet to use this, it would typically need an internal wrapper function that calls the module's logic.

        // Placeholder for actual integration logic:
        // uint256 currentAllowance = getAllowance(_owner, _spender);
        // if (block.timestamp > _deadline) {
        //     revert ERC2612InvalidSignature(_owner, _spender, _value, _deadline, _v, _r, _s);
        // }
        // The actual signature verification would happen internally within the module's implementation.

        // The module's \`permit\` function is not directly callable by a facet in this manner as per typical module patterns.
        // A facet would interact with the state managed by the module.
        // The provided \`permit\` function signature implies it handles the state update.

        // Example of how a facet might conceptually use the storage:
        // ERC20PermitStorage storage permitStorage = ERC20PermitMod.getPermitStorage();
        // ERC20Storage storage erc20Storage = ERC20PermitMod.getERC20Storage();

        // The direct call to \`ERC20PermitMod.permit\` is illustrative of the functionality,
        // but the actual integration would depend on how the module exposes its state-modifying capabilities.
        // Based on the provided data, the \`permit\` function is part of the module's internal logic.

        // A facet would typically have an internal function that uses the module's storage:
        // function _handlePermit(...) internal {
        //    // Call internal logic that reads/writes permitStorage and erc20Storage
        //    // Emit Approval event
        // }
    }
}
`}
</ExpandableCode>
-->

## Best Practices

<Callout type="tip" title="Best Practice">
- Ensure the diamond's storage layout is compatible with `ERC20PermitStorage` and `ERC20Storage`.
- Verify the domain separator is correctly configured and unique for the deployed diamond and chain ID.
- Handle the `ERC2612InvalidSignature` error, which is returned if the signature validation fails.
</Callout>

## Integration Notes

<Callout type="success" title="Shared Storage">
This module interacts with diamond storage using the `ERC20_STORAGE_POSITION` for `ERC20PermitStorage` and `compose.erc20` for `ERC20Storage`. Facets integrating this module should ensure they access these storage slots correctly. Changes to allowances made via permit operations are reflected in the shared diamond storage, visible to all facets interacting with the ERC-20 state.
</Callout>

<div style={{marginTop: "3rem", paddingTop: "2rem", borderTop: "1px solid var(--ifm-color-emphasis-200)"}}>
  <WasThisHelpful pageId="ERC20PermitMod" />
</div>

<LastUpdated date="2025-12-30T17:27:43.324Z" />
