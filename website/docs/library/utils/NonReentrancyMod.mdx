---
sidebar_position: 99
title: "NonReentrancyMod"
description: "Enforce non-reentrant execution within facets."
gitSource: "https://github.com/Perfect-Abstractions/Compose/tree/main/src/libraries/NonReentrancyMod.sol"
---

import DocSubtitle  from '@site/src/components/docs/DocSubtitle';
import Badge from '@site/src/components/ui/Badge';
import Callout from '@site/src/components/ui/Callout';
import CalloutBox from '@site/src/components/ui/CalloutBox';
import Accordion, { AccordionGroup } from '@site/src/components/ui/Accordion';
import PropertyTable from '@site/src/components/api/PropertyTable';
import ExpandableCode from '@site/src/components/code/ExpandableCode';
import CodeShowcase from '@site/src/components/code/CodeShowcase';
import RelatedDocs from '@site/src/components/docs/RelatedDocs';
import WasThisHelpful from '@site/src/components/docs/WasThisHelpful';
import LastUpdated from '@site/src/components/docs/LastUpdated';
import ReadingTime from '@site/src/components/docs/ReadingTime';
import GradientText from '@site/src/components/ui/GradientText';
import GradientButton from '@site/src/components/ui/GradientButton';

<DocSubtitle>
Enforce non-reentrant execution within facets.
</DocSubtitle>

<Callout type="info" title="Key Features">
- Prevents reentrant function calls, enhancing security.
- Simple and explicit `enter`/`exit` pattern for easy integration.
- Utilizes a single storage slot for the reentrancy guard.
</Callout>

<Callout type="info" title="Module Usage">
This module provides internal functions for use in your custom facets. Import it to access shared logic and storage.
</Callout>

## Overview

The NonReentrancyMod provides essential functions to prevent reentrant calls, ensuring the integrity and predictable execution of your diamond's facets. By managing reentrancy guards, this module safeguards against common vulnerabilities and unexpected state changes during complex transactions.

---

## Storage

### State Variables

<PropertyTable
  properties={[
    {
      name: "NON_REENTRANT_SLOT",
      type: "bytes32",
      description: "Reentrancy guard storage slot (Value: `keccak256(\"compose.nonreentrant\")`)"
    }
  ]}
  showRequired={false}
/>

## Functions

### enter

How to use as a library in user facets How to use as a modifier in user facets This unlocks the entry into a function

<ExpandableCode language="solidity" maxLines={8}>
{`function enter() ;`}
</ExpandableCode>

---
### exit

This locks the entry into a function

<ExpandableCode language="solidity" maxLines={8}>
{`function exit() ;`}
</ExpandableCode>

## Errors

<AccordionGroup>
  <Accordion title="Reentrancy" defaultOpen={false}>
    <div style={{marginBottom: "1rem"}}>
      Function selector - 0x43a0d067
    </div>

    <div>
      <strong>Signature:</strong>
      <ExpandableCode language="solidity" maxLines={5}>
error Reentrancy();
      </ExpandableCode>
    </div>
  </Accordion>
</AccordionGroup>

## Usage Example

<ExpandableCode language="solidity" maxLines={20} title="Example Implementation">
{`pragma solidity ^0.8.30;

import {LibNonReentrancy} from "@compose/diamond-proxy/contracts/modules/nonReentrancy/LibNonReentrancy.sol";

contract MyFacet {
    using LibNonReentrancy for uint256;

    uint256 private _reentrancyGuard;

    function sensitiveOperation() external {
        // Lock reentrancy before executing sensitive logic
        _reentrancyGuard.enter();

        // ... sensitive logic ...

        // Unlock reentrancy after execution
        _reentrancyGuard.exit();
    }

    function _beforeAll() internal override {
        // Initialize the reentrancy guard in the diamond storage
        // Assuming diamond storage has a slot for the guard, e.g., \`uint256 reentrancyGuard;\`
        // This initialization would typically happen once during diamond deployment or upgrade.
        // For example, if \`LibNonReentrancy.storage(LibNonReentrancy.nonReentrancyStorageSlot()).reentrancyGuard\` is accessible:
        // LibNonReentrancy.storage(LibNonReentrancy.nonReentrancyStorageSlot()).reentrancyGuard = 1; // Initialized state
    }
}`}
</ExpandableCode>

## Best Practices

<Callout type="tip" title="Best Practice">
- Always call `enter()` at the beginning and `exit()` at the end of any function susceptible to reentrancy.
- Ensure the reentrancy guard is correctly initialized within the diamond's storage during deployment or upgrade.
</Callout>

## Integration Notes

<Callout type="success" title="Shared Storage">
This module manages a reentrancy guard, typically stored as a `uint256` within the diamond's shared storage. The `enter()` function increments the guard, and `exit()` decrements it. A non-zero guard indicates the function is currently executing, preventing reentrant calls. Ensure the diamond's storage layout accommodates this guard, and that it is initialized to a non-zero value (e.g., 1) to signify the initial locked state before any function call. The `LibNonReentrancy.storage()` helper function is used to access the guard variable within the diamond's storage.
</Callout>

<div style={{marginTop: "3rem", paddingTop: "2rem", borderTop: "1px solid var(--ifm-color-emphasis-200)"}}>
  <WasThisHelpful pageId="NonReentrancyMod" />
</div>

<LastUpdated date="2025-12-23T00:02:35.058Z" />
